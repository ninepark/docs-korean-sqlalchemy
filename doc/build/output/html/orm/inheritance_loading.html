

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ko" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ko" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Loading Inheritance Hierarchies &mdash; SQLAlchemy 1.3.0b1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="Constructors and Object Initialization" href="constructors.html" />
    <link rel="prev" title="Relationship Loading Techniques" href="loading_relationships.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../contents.html" class="icon icon-home"> SQLAlchemy
          

          
          </a>

          
            
            
              <div class="version">
                1.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">SQLAlchemy ORM</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tutorial.html">객체 관계형 튜토리얼(Object Relational Tutorial)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mapper_config.html">Mapper Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="relationships.html">Relationship Configuration</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="loading_objects.html">Loading Objects</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="loading_columns.html">Loading Columns</a></li>
<li class="toctree-l3"><a class="reference internal" href="loading_relationships.html">Relationship Loading Techniques</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Loading Inheritance Hierarchies</a></li>
<li class="toctree-l3"><a class="reference internal" href="constructors.html">Constructors and Object Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="query.html">Query API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="session.html">Using the Session</a></li>
<li class="toctree-l2"><a class="reference internal" href="extending.html">Events and Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/index.html">ORM Extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html">ORM Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core/index.html">SQLAlchemy Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dialects/index.html">Dialects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../errors.html">Error Messages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog/index.html">Changes and Migration</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../contents.html">SQLAlchemy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../contents.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">SQLAlchemy ORM</a> &raquo;</li>
        
          <li><a href="loading_objects.html">Loading Objects</a> &raquo;</li>
        
      <li>Loading Inheritance Hierarchies</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/VeranosTech/docs-korean-sqlalchemy//docs-korean/doc/build/orm/inheritance_loading.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="loading-inheritance-hierarchies">
<span id="inheritance-loading-toplevel"></span><h1>Loading Inheritance Hierarchies<a class="headerlink" href="#loading-inheritance-hierarchies" title="제목 주소">¶</a></h1>
<p>When classes are mapped in inheritance hierarchies using the &quot;joined&quot;,
&quot;single&quot;, or &quot;concrete&quot; table inheritance styles as described at
<a class="reference internal" href="inheritance.html#inheritance-toplevel"><span class="std std-ref">Mapping Class Inheritance Hierarchies</span></a>, the usual behavior is that a query for a
particular base class will also yield objects corresponding to subclasses
as well.   When a single query is capable of returning a result with
a different class or subclasses per result row, we use the term
&quot;polymorphic loading&quot;.</p>
<p>Within the realm of polymorphic loading, specifically with joined and single
table inheritance, there is an additional problem of which subclass attributes
are to be queried up front, and which are to be loaded later. When an attribute
of a particular subclass is queried up front, we can use it in our query as
something to filter on, and it also will be loaded when we get our objects
back.   If it's not queried up front, it gets loaded later when we first need
to access it.   Basic control of this behavior is provided using the
<a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> function, as well as two variants, the mapper
configuration <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.params.with_polymorphic" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.with_polymorphic</span></code></a> in conjunction with
the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.params.polymorphic_load" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.polymorphic_load</span></code></a> option, and the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>
-level <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.with_polymorphic" title="sqlalchemy.orm.query.Query.with_polymorphic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.with_polymorphic()</span></code></a> method.    The &quot;with_polymorphic&quot; family
each provide a means of specifying which specific subclasses of a particular
base class should be included within a query, which implies what columns and
tables will be available in the SELECT.</p>
<div class="section" id="using-with-polymorphic">
<span id="with-polymorphic"></span><h2>Using with_polymorphic<a class="headerlink" href="#using-with-polymorphic" title="제목 주소">¶</a></h2>
<p>For the following sections, assume the <code class="docutils literal notranslate"><span class="pre">Employee</span></code> / <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> / <code class="docutils literal notranslate"><span class="pre">Manager</span></code>
examples introduced in <a class="reference internal" href="inheritance.html#inheritance-toplevel"><span class="std std-ref">Mapping Class Inheritance Hierarchies</span></a>.</p>
<p>Normally, when a <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> specifies the base class of an
inheritance hierarchy, only the columns that are local to that base
class are queried:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>Above, for both single and joined table inheritance, only the columns
local to <code class="docutils literal notranslate"><span class="pre">Employee</span></code> will be present in the SELECT.   We may get back
instances of <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> or <code class="docutils literal notranslate"><span class="pre">Manager</span></code>, however they will not have the
additional attributes loaded until we first access them, at which point a
lazy load is emitted.</p>
<p>Similarly, if we wanted to refer to columns mapped
to <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> or <code class="docutils literal notranslate"><span class="pre">Manager</span></code> in our query that's against <code class="docutils literal notranslate"><span class="pre">Employee</span></code>,
these columns aren't available directly in either the single or joined table
inheritance case, since the <code class="docutils literal notranslate"><span class="pre">Employee</span></code> entity does not refer to these columns
(note that for single-table inheritance, this is common if Declarative is used,
but not for a classical mapping).</p>
<p>To solve both of these issues, the <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> function
provides a special <a class="reference internal" href="query.html#sqlalchemy.orm.util.AliasedClass" title="sqlalchemy.orm.util.AliasedClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">AliasedClass</span></code></a> that represents a range of
columns across subclasses. This object can be used in a <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>
like any other alias.  When queried, it represents all the columns present in
the classes given:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">with_polymorphic</span>

<span class="n">eng_plus_manager</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">,</span> <span class="n">Manager</span><span class="p">])</span>

<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">eng_plus_manager</span><span class="p">)</span>
</pre></div>
</div>
<p>If the above mapping were using joined table inheritance, the SELECT
statement for the above would be:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql"></span>
<span class=" -Sql">SELECT employee.id AS employee_id,</span>
<span class=" -Sql">    engineer.id AS engineer_id,</span>
<span class=" -Sql">    manager.id AS manager_id,</span>
<span class=" -Sql">    employee.name AS employee_name,</span>
<span class=" -Sql">    employee.type AS employee_type,</span>
<span class=" -Sql">    engineer.engineer_info AS engineer_engineer_info,</span>
<span class=" -Sql">    manager.manager_data AS manager_manager_data</span>
<span class=" -Sql">FROM employee</span>
<span class=" -Sql">    LEFT OUTER JOIN engineer</span>
<span class=" -Sql">    ON employee.id = engineer.id</span>
<span class=" -Sql">    LEFT OUTER JOIN manager</span>
<span class=" -Sql">    ON employee.id = manager.id</span>
<span class=" -Sql">[]</span>
</pre></div>
</div>
<p>Where above, the additional tables / columns for &quot;engineer&quot; and &quot;manager&quot; are
included.  Similar behavior occurs in the case of single table inheritance.</p>
<p><a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> accepts a single class or
mapper, a list of classes/mappers, or the string <code class="docutils literal notranslate"><span class="pre">'*'</span></code> to indicate all
subclasses:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="c1"># include columns for Engineer</span>
<span class="n">entity</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="n">Engineer</span><span class="p">)</span>

<span class="c1"># include columns for Engineer, Manager</span>
<span class="n">entity</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">,</span> <span class="n">Manager</span><span class="p">])</span>

<span class="c1"># include columns for all mapped subclasses</span>
<span class="n">entity</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="using-aliasing-with-with-polymorphic">
<h3>Using aliasing with with_polymorphic<a class="headerlink" href="#using-aliasing-with-with-polymorphic" title="제목 주소">¶</a></h3>
<p>The <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> function also provides &quot;aliasing&quot; of the
polymorphic selectable itself, meaning, two different <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a>
entities, referring to the same class hierarchy, can be used together.  This
is available using the <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic.params.aliased" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">orm.with_polymorphic.aliased</span></code></a> flag.
For a polymorphic selectable that is across multiple tables, the default behavior
is to wrap the selectable into a subquery.  Below we emit a query that will
select for &quot;employee or manager&quot; paired with &quot;employee or engineer&quot; on employees
with the same name:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">engineer_employee</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
    <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">],</span> <span class="n">aliased</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">manager_employee</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
    <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">],</span> <span class="n">aliased</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">engineer_employee</span><span class="p">,</span> <span class="n">manager_employee</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span>
        <span class="n">manager_employee</span><span class="p">,</span>
        <span class="n">and_</span><span class="p">(</span>
            <span class="n">engineer_employee</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">manager_employee</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
            <span class="n">engineer_employee</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">manager_employee</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>
<span class="p">)</span>
<span class="n">q</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql"></span>
<span class=" -Sql">SELECT</span>
<span class=" -Sql">    anon_1.employee_id AS anon_1_employee_id,</span>
<span class=" -Sql">    anon_1.employee_name AS anon_1_employee_name,</span>
<span class=" -Sql">    anon_1.employee_type AS anon_1_employee_type,</span>
<span class=" -Sql">    anon_1.engineer_id AS anon_1_engineer_id,</span>
<span class=" -Sql">    anon_1.engineer_engineer_name AS anon_1_engineer_engineer_name,</span>
<span class=" -Sql">    anon_2.employee_id AS anon_2_employee_id,</span>
<span class=" -Sql">    anon_2.employee_name AS anon_2_employee_name,</span>
<span class=" -Sql">    anon_2.employee_type AS anon_2_employee_type,</span>
<span class=" -Sql">    anon_2.manager_id AS anon_2_manager_id,</span>
<span class=" -Sql">    anon_2.manager_manager_name AS anon_2_manager_manager_name</span>
<span class=" -Sql">FROM (</span>
<span class=" -Sql">    SELECT</span>
<span class=" -Sql">        employee.id AS employee_id,</span>
<span class=" -Sql">        employee.name AS employee_name,</span>
<span class=" -Sql">        employee.type AS employee_type,</span>
<span class=" -Sql">        engineer.id AS engineer_id,</span>
<span class=" -Sql">        engineer.engineer_name AS engineer_engineer_name</span>
<span class=" -Sql">    FROM employee</span>
<span class=" -Sql">    LEFT OUTER JOIN engineer ON employee.id = engineer.id</span>
<span class=" -Sql">) AS anon_1</span>
<span class=" -Sql">JOIN (</span>
<span class=" -Sql">    SELECT</span>
<span class=" -Sql">        employee.id AS employee_id,</span>
<span class=" -Sql">        employee.name AS employee_name,</span>
<span class=" -Sql">        employee.type AS employee_type,</span>
<span class=" -Sql">        manager.id AS manager_id,</span>
<span class=" -Sql">         manager.manager_name AS manager_manager_name</span>
<span class=" -Sql">    FROM employee</span>
<span class=" -Sql">    LEFT OUTER JOIN manager ON employee.id = manager.id</span>
<span class=" -Sql">) AS anon_2</span>
<span class=" -Sql">ON anon_1.employee_id &gt; anon_2.employee_id</span>
<span class=" -Sql">AND anon_1.employee_name = anon_2.employee_name</span>
</pre></div>
</div>
<p>The creation of subqueries above is very verbose.  While it creates the best
encapsulation of the two distinct queries, it may be inefficient.
<a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> includes an additional flag to help with this
situation, <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic.params.flat" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">orm.with_polymorphic.flat</span></code></a>, which will &quot;flatten&quot; the
subquery / join combination into straight joins, applying aliasing to the
individual tables instead.   Setting <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic.params.flat" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">orm.with_polymorphic.flat</span></code></a>
implies <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic.params.aliased" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">orm.with_polymorphic.aliased</span></code></a>, so only one flag
is necessary:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">engineer_employee</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
    <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">],</span> <span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">manager_employee</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
    <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">],</span> <span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">engineer_employee</span><span class="p">,</span> <span class="n">manager_employee</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span>
        <span class="n">manager_employee</span><span class="p">,</span>
        <span class="n">and_</span><span class="p">(</span>
            <span class="n">engineer_employee</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">manager_employee</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
            <span class="n">engineer_employee</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">manager_employee</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>
<span class="p">)</span>
<span class="n">q</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql"></span>
<span class=" -Sql">SELECT</span>
<span class=" -Sql">    employee_1.id AS employee_1_id,</span>
<span class=" -Sql">    employee_1.name AS employee_1_name,</span>
<span class=" -Sql">    employee_1.type AS employee_1_type,</span>
<span class=" -Sql">    engineer_1.id AS engineer_1_id,</span>
<span class=" -Sql">    engineer_1.engineer_name AS engineer_1_engineer_name,</span>
<span class=" -Sql">    employee_2.id AS employee_2_id,</span>
<span class=" -Sql">    employee_2.name AS employee_2_name,</span>
<span class=" -Sql">    employee_2.type AS employee_2_type,</span>
<span class=" -Sql">    manager_1.id AS manager_1_id,</span>
<span class=" -Sql">    manager_1.manager_name AS manager_1_manager_name</span>
<span class=" -Sql">FROM employee AS employee_1</span>
<span class=" -Sql">LEFT OUTER JOIN engineer AS engineer_1</span>
<span class=" -Sql">ON employee_1.id = engineer_1.id</span>
<span class=" -Sql">JOIN (</span>
<span class=" -Sql">    employee AS employee_2</span>
<span class=" -Sql">    LEFT OUTER JOIN manager AS manager_1</span>
<span class=" -Sql">    ON employee_2.id = manager_1.id</span>
<span class=" -Sql">)</span>
<span class=" -Sql">ON employee_1.id &gt; employee_2.id</span>
<span class=" -Sql">AND employee_1.name = employee_2.name</span>
</pre></div>
</div>
<p>Note above, when using <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic.params.flat" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">orm.with_polymorphic.flat</span></code></a>, it is often the
case when used in conjunction with joined table inheritance that we get a
right-nested JOIN in our statement.   Some older databases, in particular older
versions of SQLite, may have a problem with this syntax, although virtually all
modern database versions now support this syntax.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">The <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic.params.flat" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">orm.with_polymorphic.flat</span></code></a> flag only applies to the use
of <code class="xref py py-paramref docutils literal notranslate"><span class="pre">with_polymorphic</span></code> with <strong>joined table inheritance</strong> and when
the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.with_polymorphic.params.selectable" title="sqlalchemy.orm.query.Query.with_polymorphic"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">with_polymorphic.selectable</span></code></a> argument is <strong>not</strong> used.</p>
</div>
</div>
<div class="section" id="referring-to-specific-subclass-attributes">
<h3>Referring to Specific Subclass Attributes<a class="headerlink" href="#referring-to-specific-subclass-attributes" title="제목 주소">¶</a></h3>
<p>The entity returned by <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> is an <a class="reference internal" href="query.html#sqlalchemy.orm.util.AliasedClass" title="sqlalchemy.orm.util.AliasedClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">AliasedClass</span></code></a>
object, which can be used in a <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> like any other alias, including
named attributes for those attributes on the <code class="docutils literal notranslate"><span class="pre">Employee</span></code> class.   In our
previous example, <code class="docutils literal notranslate"><span class="pre">eng_plus_manager</span></code> becomes the entity that we use to refer to the
three-way outer join above.  It also includes namespaces for each class named
in the list of classes, so that attributes specific to those subclasses can be
called upon as well.   The following example illustrates calling upon attributes
specific to <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> as well as <code class="docutils literal notranslate"><span class="pre">Manager</span></code> in terms of <code class="docutils literal notranslate"><span class="pre">eng_plus_manager</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">eng_plus_manager</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">,</span> <span class="n">Manager</span><span class="p">])</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">eng_plus_manager</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">or_</span><span class="p">(</span>
                    <span class="n">eng_plus_manager</span><span class="o">.</span><span class="n">Engineer</span><span class="o">.</span><span class="n">engineer_info</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
                    <span class="n">eng_plus_manager</span><span class="o">.</span><span class="n">Manager</span><span class="o">.</span><span class="n">manager_data</span><span class="o">==</span><span class="s1">&#39;y&#39;</span>
                <span class="p">)</span>
            <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="setting-with-polymorphic-at-mapper-configuration-time">
<span id="with-polymorphic-mapper-config"></span><h3>Setting with_polymorphic at mapper configuration time<a class="headerlink" href="#setting-with-polymorphic-at-mapper-configuration-time" title="제목 주소">¶</a></h3>
<p>The <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> function serves the purpose of allowing
&quot;eager&quot; loading of attributes from subclass tables, as well as the ability
to refer to the attributes from subclass tables at query time.   Historically,
the &quot;eager loading&quot; of columns has been the more important part of the
equation.   So just as eager loading for relationships can be specified
as a configurational option, the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.params.with_polymorphic" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.with_polymorphic</span></code></a>
configuration parameter allows an entity to use a polymorphic load by
default.  We can add the parameter to our <code class="docutils literal notranslate"><span class="pre">Employee</span></code> mapping
first introduced at <a class="reference internal" href="inheritance.html#joined-inheritance"><span class="std std-ref">Joined Table Inheritance</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;employee&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_on&#39;</span><span class="p">:</span><span class="nb">type</span><span class="p">,</span>
        <span class="s1">&#39;with_polymorphic&#39;</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Above is a common setting for <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.params.with_polymorphic" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.with_polymorphic</span></code></a>,
which is to indicate an asterisk to load all subclass columns.   In the
case of joined table inheritance, this option
should be used sparingly, as it implies that the mapping will always emit
a (often large) series of LEFT OUTER JOIN to many tables, which is not
efficient from a SQL perspective.   For single table inheritance, specifying the
asterisk is often a good idea as the load is still against a single table only,
but an additional lazy load of subclass-mapped columns will be prevented.</p>
<p>Using <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> or <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.with_polymorphic" title="sqlalchemy.orm.query.Query.with_polymorphic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.with_polymorphic()</span></code></a>
will override the mapper-level <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.params.with_polymorphic" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.with_polymorphic</span></code></a> setting.</p>
<p>The <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.params.with_polymorphic" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.with_polymorphic</span></code></a> option also accepts a list of
classes just like <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> to polymorphically load among
a subset of classes.  However, when using Declarative, providing classes
to this list is not directly possible as the subclasses we'd like to add
are not available yet.   Instead, we can specify on each subclass
that they should individually participate in polymorphic loading by
default using the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.params.polymorphic_load" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.polymorphic_load</span></code></a> parameter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;engineer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">engineer_info</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;engineer&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_load&#39;</span><span class="p">:</span> <span class="s1">&#39;inline&#39;</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;manager&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">manager_data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;manager&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_load&#39;</span><span class="p">:</span> <span class="s1">&#39;inline&#39;</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Setting the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.params.polymorphic_load" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.polymorphic_load</span></code></a> parameter to the value
<code class="docutils literal notranslate"><span class="pre">&quot;inline&quot;</span></code> means that the <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> and <code class="docutils literal notranslate"><span class="pre">Manager</span></code> classes above
are part of the &quot;polymorphic load&quot; of the base <code class="docutils literal notranslate"><span class="pre">Employee</span></code> class by default,
exactly as though they had been appended to the
<a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.params.with_polymorphic" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.with_polymorphic</span></code></a> list of classes.</p>
</div>
<div class="section" id="setting-with-polymorphic-against-a-query">
<h3>Setting with_polymorphic against a query<a class="headerlink" href="#setting-with-polymorphic-against-a-query" title="제목 주소">¶</a></h3>
<p>The <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> function evolved from a query-level
method <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.with_polymorphic" title="sqlalchemy.orm.query.Query.with_polymorphic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.with_polymorphic()</span></code></a>.  This method has the same purpose
as <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a>, except is not as
flexible in its usage patterns in that it only applies to the first entity
of the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>.   It then takes effect for all occurrences of
that entity, so that the entity (and its subclasses) can be referred to
directly, rather than using an alias object.  For simple cases it might be
considered to be more succinct:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">with_polymorphic</span><span class="p">([</span><span class="n">Engineer</span><span class="p">,</span> <span class="n">Manager</span><span class="p">])</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span>
        <span class="n">or_</span><span class="p">(</span>
            <span class="n">Engineer</span><span class="o">.</span><span class="n">engineer_info</span><span class="o">==</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
            <span class="n">Manager</span><span class="o">.</span><span class="n">manager_data</span><span class="o">==</span><span class="s1">&#39;q&#39;</span>
        <span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.with_polymorphic" title="sqlalchemy.orm.query.Query.with_polymorphic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.with_polymorphic()</span></code></a> method has a more complicated job
than the <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> function, as it needs to correctly
transform entities like <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> and <code class="docutils literal notranslate"><span class="pre">Manager</span></code> appropriately, but
not interfere with other entities.  If its flexibility is lacking, switch
to using <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a>.</p>
</div>
</div>
<div class="section" id="polymorphic-selectin-loading">
<span id="polymorphic-selectin"></span><h2>Polymorphic Selectin Loading<a class="headerlink" href="#polymorphic-selectin-loading" title="제목 주소">¶</a></h2>
<p>An alternative to using the <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> family of
functions to &quot;eagerly&quot; load the additional subclasses on an inheritance
mapping, primarily when using joined table inheritance, is to use polymorphic
&quot;selectin&quot; loading.   This is an eager loading
feature which works similarly to the <a class="reference internal" href="loading_relationships.html#selectin-eager-loading"><span class="std std-ref">Select IN loading</span></a> feature
of relationship loading.   Given our example mapping, we can instruct
a load of <code class="docutils literal notranslate"><span class="pre">Employee</span></code> to emit an extra SELECT per subclass by using
the <a class="reference internal" href="#sqlalchemy.orm.selectin_polymorphic" title="sqlalchemy.orm.selectin_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.selectin_polymorphic()</span></code></a> loader option:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">selectin_polymorphic</span>

<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">selectin_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">,</span> <span class="n">Engineer</span><span class="p">])</span>
<span class="p">)</span>
</pre></div>
</div>
<p>When the above query is run, two additional SELECT statements will
be emitted:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">query.all()</span>
<span class=" -Sql">SELECT</span>
<span class=" -Sql">    employee.id AS employee_id,</span>
<span class=" -Sql">    employee.name AS employee_name,</span>
<span class=" -Sql">    employee.type AS employee_type</span>
<span class=" -Sql">FROM employee</span>
<span class=" -Sql">()</span>

<span class=" -Sql">SELECT</span>
<span class=" -Sql">    engineer.id AS engineer_id,</span>
<span class=" -Sql">    employee.id AS employee_id,</span>
<span class=" -Sql">    employee.type AS employee_type,</span>
<span class=" -Sql">    engineer.engineer_name AS engineer_engineer_name</span>
<span class=" -Sql">FROM employee JOIN engineer ON employee.id = engineer.id</span>
<span class=" -Sql">WHERE employee.id IN (?, ?) ORDER BY employee.id</span>
<span class=" -Sql">(1, 2)</span>

<span class=" -Sql">SELECT</span>
<span class=" -Sql">    manager.id AS manager_id,</span>
<span class=" -Sql">    employee.id AS employee_id,</span>
<span class=" -Sql">    employee.type AS employee_type,</span>
<span class=" -Sql">    manager.manager_name AS manager_manager_name</span>
<span class=" -Sql">FROM employee JOIN manager ON employee.id = manager.id</span>
<span class=" -Sql">WHERE employee.id IN (?) ORDER BY employee.id</span>
<span class=" -Sql">(3,)</span>
</pre></div>
</div>
<p>We can similarly establish the above style of loading to take place
by default by specifying the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.params.polymorphic_load" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.polymorphic_load</span></code></a> parameter,
using the value <code class="docutils literal notranslate"><span class="pre">&quot;selectin&quot;</span></code> on a per-subclass basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span> <span class="s1">&#39;employee&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_on&#39;</span><span class="p">:</span> <span class="nb">type</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;engineer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">engineer_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_load&#39;</span><span class="p">:</span> <span class="s1">&#39;selectin&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span> <span class="s1">&#39;engineer&#39;</span><span class="p">,</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;manager&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">manager_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_load&#39;</span><span class="p">:</span> <span class="s1">&#39;selectin&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span> <span class="s1">&#39;manager&#39;</span><span class="p">,</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Unlike when using <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a>, when using the
<a class="reference internal" href="#sqlalchemy.orm.selectin_polymorphic" title="sqlalchemy.orm.selectin_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.selectin_polymorphic()</span></code></a> style of loading, we do <strong>not</strong> have the
ability to refer to the <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> or <code class="docutils literal notranslate"><span class="pre">Manager</span></code> entities within our main
query as filter, order by, or other criteria, as these entities are not present
in the initial query that is used to locate results.   However, we can apply
loader options that apply towards <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> or <code class="docutils literal notranslate"><span class="pre">Manager</span></code>, which will take
effect when the secondary SELECT is emitted.  Below we assume <code class="docutils literal notranslate"><span class="pre">Manager</span></code> has
an additional relationship <code class="docutils literal notranslate"><span class="pre">Manager.paperwork</span></code>, that we'd like to eagerly
load as well.  We can use any type of eager loading, such as joined eager
loading via the <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">joinedload</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">selectin_polymorphic</span>

<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">selectin_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">,</span> <span class="n">Engineer</span><span class="p">]),</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="n">Manager</span><span class="o">.</span><span class="n">paperwork</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Using the query above, we get three SELECT statements emitted, however
the one against <code class="docutils literal notranslate"><span class="pre">Manager</span></code> will be:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">manager_id</span><span class="p">,</span>
    <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">employee_id</span><span class="p">,</span>
    <span class="n">employee</span><span class="p">.</span><span class="k">type</span> <span class="k">AS</span> <span class="n">employee_type</span><span class="p">,</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">manager_name</span> <span class="k">AS</span> <span class="n">manager_manager_name</span><span class="p">,</span>
    <span class="n">paperwork_1</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">paperwork_1_id</span><span class="p">,</span>
    <span class="n">paperwork_1</span><span class="p">.</span><span class="n">manager_id</span> <span class="k">AS</span> <span class="n">paperwork_1_manager_id</span><span class="p">,</span>
    <span class="n">paperwork_1</span><span class="p">.</span><span class="k">data</span> <span class="k">AS</span> <span class="n">paperwork_1_data</span>
<span class="k">FROM</span> <span class="n">employee</span> <span class="k">JOIN</span> <span class="n">manager</span> <span class="k">ON</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">id</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">paperwork</span> <span class="k">AS</span> <span class="n">paperwork_1</span>
<span class="k">ON</span> <span class="n">manager</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">paperwork_1</span><span class="p">.</span><span class="n">manager_id</span>
<span class="k">WHERE</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="o">?</span><span class="p">)</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,)</span>
</pre></div>
</div>
<p>Note that selectin polymorphic loading has similar caveats as that of
selectin relationship loading; for entities that make use of a composite
primary key, the database in use must support tuples with &quot;IN&quot;, currently
known to work with MySQL and PostgreSQL.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 1.2에 추가.</span></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">경고</p>
<p class="last">The selectin polymorphic loading feature should be considered
as <strong>experimental</strong> within early releases of the 1.2 series.</p>
</div>
<div class="section" id="combining-selectin-and-with-polymorphic">
<span id="polymorphic-selectin-and-withpoly"></span><h3>Combining selectin and with_polymorphic<a class="headerlink" href="#combining-selectin-and-with-polymorphic" title="제목 주소">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">works as of 1.2.0b3</p>
</div>
<p>With careful planning, selectin loading can be applied against a hierarchy
that itself uses &quot;with_polymorphic&quot;.  A particular use case is that of
using selectin loading to load a joined-inheritance subtable, which then
uses &quot;with_polymorphic&quot; to refer to further sub-classes, which may be
joined- or single-table inheritance.  If we added a class <code class="docutils literal notranslate"><span class="pre">VicePresident</span></code> that
extends <code class="docutils literal notranslate"><span class="pre">Manager</span></code> using single-table inheritance, we could ensure that
a load of <code class="docutils literal notranslate"><span class="pre">Manager</span></code> also fully loads <code class="docutils literal notranslate"><span class="pre">VicePresident</span></code> subtypes at the same time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># use &quot;Employee&quot; example from the enclosing section</span>

<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;manager&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">manager_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_load&#39;</span><span class="p">:</span> <span class="s1">&#39;selectin&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span> <span class="s1">&#39;manager&#39;</span><span class="p">,</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">VicePresident</span><span class="p">(</span><span class="n">Manager</span><span class="p">):</span>
    <span class="n">vp_info</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_load&quot;</span><span class="p">:</span> <span class="s2">&quot;inline&quot;</span><span class="p">,</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;vp&quot;</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Above, we add a <code class="docutils literal notranslate"><span class="pre">vp_info</span></code> column to the <code class="docutils literal notranslate"><span class="pre">manager</span></code> table, local to the
<code class="docutils literal notranslate"><span class="pre">VicePresident</span></code> subclass.   This subclass is linked to the polymorphic
identity <code class="docutils literal notranslate"><span class="pre">&quot;vp&quot;</span></code> which refers to rows which have this data.     By setting the
load style to &quot;inline&quot;, it means that a load of <code class="docutils literal notranslate"><span class="pre">Manager</span></code> objects will also
ensure that the <code class="docutils literal notranslate"><span class="pre">vp_info</span></code> column is queried for in the same SELECT statement.
A query against <code class="docutils literal notranslate"><span class="pre">Employee</span></code> that encounters a <code class="docutils literal notranslate"><span class="pre">Manager</span></code> row would emit
similarly to the following:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">employee_id</span><span class="p">,</span> <span class="n">employee</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">employee_name</span><span class="p">,</span>
       <span class="n">employee</span><span class="p">.</span><span class="k">type</span> <span class="k">AS</span> <span class="n">employee_type</span>
<span class="k">FROM</span> <span class="n">employee</span>
<span class="p">)</span>

<span class="k">SELECT</span> <span class="n">manager</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">manager_id</span><span class="p">,</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">employee_id</span><span class="p">,</span>
       <span class="n">employee</span><span class="p">.</span><span class="k">type</span> <span class="k">AS</span> <span class="n">employee_type</span><span class="p">,</span>
       <span class="n">manager</span><span class="p">.</span><span class="n">manager_name</span> <span class="k">AS</span> <span class="n">manager_manager_name</span><span class="p">,</span>
       <span class="n">manager</span><span class="p">.</span><span class="n">vp_info</span> <span class="k">AS</span> <span class="n">manager_vp_info</span>
<span class="k">FROM</span> <span class="n">employee</span> <span class="k">JOIN</span> <span class="n">manager</span> <span class="k">ON</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="o">?</span><span class="p">)</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
</pre></div>
</div>
<p>Combining &quot;selectin&quot; polymorhic loading with query-time
<a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> usage is also possible (though this is very
outer-space stuff!); assuming the above mappings had no <code class="docutils literal notranslate"><span class="pre">polymorphic_load</span></code>
set up, we could get the same result as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">with_polymorphic</span><span class="p">,</span> <span class="n">selectin_polymorphic</span>

<span class="n">manager_poly</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Manager</span><span class="p">,</span> <span class="p">[</span><span class="n">VicePresident</span><span class="p">])</span>

<span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">selectin_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">manager_poly</span><span class="p">]))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="referring-to-specific-subtypes-on-relationships">
<span id="inheritance-of-type"></span><h2>Referring to specific subtypes on relationships<a class="headerlink" href="#referring-to-specific-subtypes-on-relationships" title="제목 주소">¶</a></h2>
<p>Mapped attributes which correspond to a <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> are used
in querying in order to refer to the linkage between two mappings.  Common
uses for this are to refer to a <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> in <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.join" title="sqlalchemy.orm.query.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a>
as well as in loader options like <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a>.   When using
<a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> where the target class is an inheritance hierarchy,
the API allows that the join, eager load, or other linkage should target a specific
subclass, alias, or <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> alias, of that class hierarchy,
rather than the class directly targeted by the <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>.</p>
<p>The <a class="reference internal" href="internals.html#sqlalchemy.orm.interfaces.PropComparator.of_type" title="sqlalchemy.orm.interfaces.PropComparator.of_type"><code class="xref py py-func docutils literal notranslate"><span class="pre">of_type()</span></code></a> method allows the
construction of joins along <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> paths while
narrowing the criterion to specific derived aliases or subclasses. Suppose the
<code class="docutils literal notranslate"><span class="pre">employees</span></code> table represents a collection of employees which are associated
with a <code class="docutils literal notranslate"><span class="pre">Company</span></code> object. We'll add a <code class="docutils literal notranslate"><span class="pre">company_id</span></code> column to the
<code class="docutils literal notranslate"><span class="pre">employees</span></code> table and a new table <code class="docutils literal notranslate"><span class="pre">companies</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Company</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;company&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">employees</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Employee&quot;</span><span class="p">,</span>
                    <span class="n">backref</span><span class="o">=</span><span class="s1">&#39;company&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
    <span class="n">company_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;company.id&#39;</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_on&#39;</span><span class="p">:</span><span class="nb">type</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;employee&#39;</span><span class="p">,</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;engineer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">engineer_info</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;engineer&#39;</span><span class="p">}</span>

<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;manager&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">manager_data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;manager&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>When querying from <code class="docutils literal notranslate"><span class="pre">Company</span></code> onto the <code class="docutils literal notranslate"><span class="pre">Employee</span></code> relationship, the
<a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.join" title="sqlalchemy.orm.query.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> method as well as operators like <a class="reference internal" href="internals.html#sqlalchemy.orm.interfaces.PropComparator.any" title="sqlalchemy.orm.interfaces.PropComparator.any"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PropComparator.any()</span></code></a>
and <a class="reference internal" href="internals.html#sqlalchemy.orm.interfaces.PropComparator.has" title="sqlalchemy.orm.interfaces.PropComparator.has"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PropComparator.has()</span></code></a> will create
a join from <code class="docutils literal notranslate"><span class="pre">company</span></code> to <code class="docutils literal notranslate"><span class="pre">employee</span></code>, without including <code class="docutils literal notranslate"><span class="pre">engineer</span></code> or
<code class="docutils literal notranslate"><span class="pre">manager</span></code> in the mix. If we wish to have criterion which is specifically
against the <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> class, we can tell those methods to join or subquery
against the set of columns representing the subclass using the
<a class="reference internal" href="internals.html#sqlalchemy.orm.interfaces.PropComparator.of_type" title="sqlalchemy.orm.interfaces.PropComparator.of_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">of_type()</span></code></a> operator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span><span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">Engineer</span><span class="p">))</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Engineer</span><span class="o">.</span><span class="n">engineer_info</span><span class="o">==</span><span class="s1">&#39;someinfo&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, to join from <code class="docutils literal notranslate"><span class="pre">Company</span></code> to the polymorphic entity that includes both
<code class="docutils literal notranslate"><span class="pre">Engineer</span></code> and <code class="docutils literal notranslate"><span class="pre">Manager</span></code> columns:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">manager_and_engineer</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
                            <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">,</span> <span class="n">Engineer</span><span class="p">])</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span><span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">manager_and_engineer</span><span class="p">))</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span>
        <span class="n">or_</span><span class="p">(</span>
            <span class="n">manager_and_engineer</span><span class="o">.</span><span class="n">Engineer</span><span class="o">.</span><span class="n">engineer_info</span> <span class="o">==</span> <span class="s1">&#39;someinfo&#39;</span><span class="p">,</span>
            <span class="n">manager_and_engineer</span><span class="o">.</span><span class="n">Manager</span><span class="o">.</span><span class="n">manager_data</span> <span class="o">==</span> <span class="s1">&#39;somedata&#39;</span>
        <span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="internals.html#sqlalchemy.orm.interfaces.PropComparator.any" title="sqlalchemy.orm.interfaces.PropComparator.any"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PropComparator.any()</span></code></a> and <a class="reference internal" href="internals.html#sqlalchemy.orm.interfaces.PropComparator.has" title="sqlalchemy.orm.interfaces.PropComparator.has"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PropComparator.has()</span></code></a> operators also
can be used with <a class="reference internal" href="internals.html#sqlalchemy.orm.interfaces.PropComparator.of_type" title="sqlalchemy.orm.interfaces.PropComparator.of_type"><code class="xref py py-func docutils literal notranslate"><span class="pre">of_type()</span></code></a>,
such as when the embedded criterion is in terms of a subclass:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
        <span class="nb">filter</span><span class="p">(</span>
            <span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">Engineer</span><span class="p">)</span><span class="o">.</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">Engineer</span><span class="o">.</span><span class="n">engineer_info</span><span class="o">==</span><span class="s1">&#39;someinfo&#39;</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="eager-loading-of-specific-or-polymorphic-subtypes">
<span id="eagerloading-polymorphic-subtypes"></span><h3>Eager Loading of Specific or Polymorphic Subtypes<a class="headerlink" href="#eager-loading-of-specific-or-polymorphic-subtypes" title="제목 주소">¶</a></h3>
<p>The <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a>, <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.subqueryload" title="sqlalchemy.orm.subqueryload"><code class="xref py py-func docutils literal notranslate"><span class="pre">subqueryload()</span></code></a>, <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.contains_eager" title="sqlalchemy.orm.contains_eager"><code class="xref py py-func docutils literal notranslate"><span class="pre">contains_eager()</span></code></a> and
other eagerloader options support
paths which make use of <code class="xref py py-func docutils literal notranslate"><span class="pre">of_type()</span></code>.
Below, we load <code class="docutils literal notranslate"><span class="pre">Company</span></code> rows while eagerly loading related <code class="docutils literal notranslate"><span class="pre">Engineer</span></code>
objects, querying the <code class="docutils literal notranslate"><span class="pre">employee</span></code> and <code class="docutils literal notranslate"><span class="pre">engineer</span></code> tables simultaneously:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">options</span><span class="p">(</span>
        <span class="n">subqueryload</span><span class="p">(</span><span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">Engineer</span><span class="p">))</span><span class="o">.</span>
        <span class="n">subqueryload</span><span class="p">(</span><span class="n">Engineer</span><span class="o">.</span><span class="n">machines</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>As is the case with <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.join" title="sqlalchemy.orm.query.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a>, <a class="reference internal" href="internals.html#sqlalchemy.orm.interfaces.PropComparator.of_type" title="sqlalchemy.orm.interfaces.PropComparator.of_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">of_type()</span></code></a>
can be used to combine eager loading and <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a>,
so that all sub-attributes of all referenced subtypes
can be loaded:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">manager_and_engineer</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
                            <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">,</span> <span class="n">Engineer</span><span class="p">],</span>
                            <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">options</span><span class="p">(</span>
        <span class="n">joinedload</span><span class="p">(</span>
            <span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">manager_and_engineer</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>When using <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_polymorphic()</span></code></a> in conjunction with
<a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a>, the <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_polymorphic()</span></code></a> object must be against
an &quot;aliased&quot; object, that is an instance of <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a>, so that the
polymorphic selectable is aliased (an informative error message is raised
otherwise).</p>
<p class="last">The typical way to do this is to include the
<a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.with_polymorphic.params.aliased" title="sqlalchemy.orm.query.Query.with_polymorphic"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">with_polymorphic.aliased</span></code></a> or <code class="xref py py-paramref docutils literal notranslate"><span class="pre">flat</span></code> flag, which will
apply this aliasing automatically.  However, if the
<a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.with_polymorphic.params.selectable" title="sqlalchemy.orm.query.Query.with_polymorphic"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">with_polymorphic.selectable</span></code></a> argument is being used to pass an
object that is already an <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> object then this flag should
<strong>not</strong> be set.  The &quot;flat&quot; option implies the &quot;aliased&quot; option and is an
alternate form of aliasing against join objects that produces fewer
subqueries.</p>
</div>
<p>Once <a class="reference internal" href="internals.html#sqlalchemy.orm.interfaces.PropComparator.of_type" title="sqlalchemy.orm.interfaces.PropComparator.of_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">of_type()</span></code></a> is the target of the eager load,
that's the entity we would use for subsequent chaining, not the original class
or derived class.  If we wanted to further eager load a collection on the
eager-loaded <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> class, we access this class from the namespace of the
<a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">options</span><span class="p">(</span>
        <span class="n">joinedload</span><span class="p">(</span><span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">manager_and_engineer</span><span class="p">))</span><span class="o">.</span>\
        <span class="n">subqueryload</span><span class="p">(</span><span class="n">manager_and_engineer</span><span class="o">.</span><span class="n">Engineer</span><span class="o">.</span><span class="n">computers</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="loading-objects-with-joined-table-inheritance">
<span id="loading-joined-inheritance"></span><h2>Loading objects with joined table inheritance<a class="headerlink" href="#loading-objects-with-joined-table-inheritance" title="제목 주소">¶</a></h2>
<p>When using joined table inheritance, if we query for a specific subclass
that represents a JOIN of two tables such as our <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> example
from the inheritance section, the SQL emitted is a join:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Engineer</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>The above query will emit SQL like:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql"></span>
<span class=" -Sql">SELECT employee.id AS employee_id,</span>
<span class=" -Sql">    employee.name AS employee_name, employee.type AS employee_type,</span>
<span class=" -Sql">    engineer.name AS engineer_name</span>
<span class=" -Sql">FROM employee JOIN engineer</span>
<span class=" -Sql">ON employee.id = engineer.id</span>
</pre></div>
</div>
<p>We will then get a collection of <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> objects back, which will
contain all columns from <code class="docutils literal notranslate"><span class="pre">employee</span></code> and <code class="docutils literal notranslate"><span class="pre">engineer</span></code> loaded.</p>
<p>However, when emitting a <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> against a base class, the behavior
is to load only from the base table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>Above, the default behavior would be to SELECT only from the <code class="docutils literal notranslate"><span class="pre">employee</span></code>
table and not from any &quot;sub&quot; tables (<code class="docutils literal notranslate"><span class="pre">engineer</span></code> and <code class="docutils literal notranslate"><span class="pre">manager</span></code>, in our
previous examples):</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql"></span>
<span class=" -Sql">SELECT employee.id AS employee_id,</span>
<span class=" -Sql">    employee.name AS employee_name, employee.type AS employee_type</span>
<span class=" -Sql">FROM employee</span>
<span class=" -Sql">[]</span>
</pre></div>
</div>
<p>After a collection of <code class="docutils literal notranslate"><span class="pre">Employee</span></code> objects has been returned from the
query, and as attributes are requested from those <code class="docutils literal notranslate"><span class="pre">Employee</span></code> objects which are
represented in either the <code class="docutils literal notranslate"><span class="pre">engineer</span></code> or <code class="docutils literal notranslate"><span class="pre">manager</span></code> child tables, a second
load is issued for the columns in that related row, if the data was not
already loaded. So above, after accessing the objects you'd see further SQL
issued along the lines of:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql"></span>
<span class=" -Sql">SELECT manager.id AS manager_id,</span>
<span class=" -Sql">    manager.manager_data AS manager_manager_data</span>
<span class=" -Sql">FROM manager</span>
<span class=" -Sql">WHERE ? = manager.id</span>
<span class=" -Sql">[5]</span>
<span class=" -Sql">SELECT engineer.id AS engineer_id,</span>
<span class=" -Sql">    engineer.engineer_info AS engineer_engineer_info</span>
<span class=" -Sql">FROM engineer</span>
<span class=" -Sql">WHERE ? = engineer.id</span>
<span class=" -Sql">[2]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a>
function and related configuration options allow us to instead emit a JOIN up
front which will conditionally load against <code class="docutils literal notranslate"><span class="pre">employee</span></code>, <code class="docutils literal notranslate"><span class="pre">engineer</span></code>, or
<code class="docutils literal notranslate"><span class="pre">manager</span></code>, very much like joined eager loading works for relationships,
removing the necessity for a second per-entity load:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">with_polymorphic</span>

<span class="n">eng_plus_manager</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">,</span> <span class="n">Manager</span><span class="p">])</span>

<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">eng_plus_manager</span><span class="p">)</span>
</pre></div>
</div>
<p>The above produces a query which joins the <code class="docutils literal notranslate"><span class="pre">employee</span></code> table to both the
<code class="docutils literal notranslate"><span class="pre">engineer</span></code> and <code class="docutils literal notranslate"><span class="pre">manager</span></code> tables like the following:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql"></span>
<span class=" -Sql">SELECT employee.id AS employee_id,</span>
<span class=" -Sql">    engineer.id AS engineer_id,</span>
<span class=" -Sql">    manager.id AS manager_id,</span>
<span class=" -Sql">    employee.name AS employee_name,</span>
<span class=" -Sql">    employee.type AS employee_type,</span>
<span class=" -Sql">    engineer.engineer_info AS engineer_engineer_info,</span>
<span class=" -Sql">    manager.manager_data AS manager_manager_data</span>
<span class=" -Sql">FROM employee</span>
<span class=" -Sql">    LEFT OUTER JOIN engineer</span>
<span class=" -Sql">    ON employee.id = engineer.id</span>
<span class=" -Sql">    LEFT OUTER JOIN manager</span>
<span class=" -Sql">    ON employee.id = manager.id</span>
<span class=" -Sql">[]</span>
</pre></div>
</div>
<p>The section <a class="reference internal" href="#with-polymorphic"><span class="std std-ref">Using with_polymorphic</span></a> discusses the <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a>
function and its configurational variants.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#with-polymorphic"><span class="std std-ref">Using with_polymorphic</span></a></p>
</div>
</div>
<div class="section" id="loading-objects-with-single-table-inheritance">
<span id="loading-single-inheritance"></span><h2>Loading objects with single table inheritance<a class="headerlink" href="#loading-objects-with-single-table-inheritance" title="제목 주소">¶</a></h2>
<p>In modern Declarative, single inheritance mappings produce <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>
objects that are mapped only to a subclass, and not available from the
superclass, even though they are present on the same table.
In our example from <a class="reference internal" href="inheritance.html#single-inheritance"><span class="std std-ref">Single Table Inheritance</span></a>, the <code class="docutils literal notranslate"><span class="pre">Manager</span></code> mapping for example had a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> specified:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">manager_data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;manager&#39;</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Above, there would be no <code class="docutils literal notranslate"><span class="pre">Employee.manager_data</span></code>
attribute, even though the <code class="docutils literal notranslate"><span class="pre">employee</span></code> table has a <code class="docutils literal notranslate"><span class="pre">manager_data</span></code> column.
A query against <code class="docutils literal notranslate"><span class="pre">Manager</span></code> will include this column in the query, as well
as an IN clause to limit rows only to <code class="docutils literal notranslate"><span class="pre">Manager</span></code> objects:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Manager</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql"></span>
<span class=" -Sql">SELECT</span>
<span class=" -Sql">    employee.id AS employee_id,</span>
<span class=" -Sql">    employee.name AS employee_name,</span>
<span class=" -Sql">    employee.type AS employee_type,</span>
<span class=" -Sql">    employee.manager_data AS employee_manager_data</span>
<span class=" -Sql">FROM employee</span>
<span class=" -Sql">WHERE employee.type IN (?)</span>

<span class=" -Sql">(&#39;manager&#39;,)</span>
</pre></div>
</div>
<p>However, in a similar way to that of joined table inheritance, a query
against <code class="docutils literal notranslate"><span class="pre">Employee</span></code> will only query for columns mapped to <code class="docutils literal notranslate"><span class="pre">Employee</span></code>:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql"></span>
<span class=" -Sql">SELECT employee.id AS employee_id,</span>
<span class=" -Sql">    employee.name AS employee_name,</span>
<span class=" -Sql">    employee.type AS employee_type</span>
<span class=" -Sql">FROM employee</span>
</pre></div>
</div>
<p>If we get back an instance of <code class="docutils literal notranslate"><span class="pre">Manager</span></code> from our result, accessing
additional columns only mapped to <code class="docutils literal notranslate"><span class="pre">Manager</span></code> emits a lazy load
for those columns, in a similar way to joined inheritance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SELECT employee.manager_data AS employee_manager_data
FROM employee
WHERE employee.id = ? AND employee.type IN (?)
</pre></div>
</div>
<p>The <a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a> function serves a similar role as  joined
inheritance in the case of single inheritance; it allows both for eager loading
of subclass attributes as well as specification of subclasses in a query,
just without the overhead of using OUTER JOIN:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">employee_poly</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">employee_poly</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
    <span class="n">or_</span><span class="p">(</span>
        <span class="n">employee_poly</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
        <span class="n">employee_poly</span><span class="o">.</span><span class="n">Manager</span><span class="o">.</span><span class="n">manager_data</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Above, our query remains against a single table however we can refer to the
columns present in <code class="docutils literal notranslate"><span class="pre">Manager</span></code> or <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> using the &quot;polymorphic&quot; namespace.
Since we specified <code class="docutils literal notranslate"><span class="pre">&quot;*&quot;</span></code> for the entities, both <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> and
<code class="docutils literal notranslate"><span class="pre">Manager</span></code> will be loaded at once.  SQL emitted would be:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">q</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql"></span>
<span class=" -Sql">SELECT</span>
<span class=" -Sql">    employee.id AS employee_id, employee.name AS employee_name,</span>
<span class=" -Sql">    employee.type AS employee_type,</span>
<span class=" -Sql">    employee.manager_data AS employee_manager_data,</span>
<span class=" -Sql">    employee.engineer_info AS employee_engineer_info</span>
<span class=" -Sql">FROM employee</span>
<span class=" -Sql">WHERE employee.name = :name_1</span>
<span class=" -Sql">OR employee.manager_data = :manager_data_1</span>
</pre></div>
</div>
</div>
<div class="section" id="inheritance-loading-api">
<h2>Inheritance Loading API<a class="headerlink" href="#inheritance-loading-api" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="sqlalchemy.orm.with_polymorphic">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">with_polymorphic</code><span class="sig-paren">(</span><em>base</em>, <em>classes</em>, <em>selectable=False</em>, <em>flat=False</em>, <em>polymorphic_on=None</em>, <em>aliased=False</em>, <em>innerjoin=False</em>, <em>_use_mapper_path=False</em>, <em>_existing_alias=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.with_polymorphic" title="정의 주소">¶</a></dt>
<dd><p>Produce an <a class="reference internal" href="query.html#sqlalchemy.orm.util.AliasedClass" title="sqlalchemy.orm.util.AliasedClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">AliasedClass</span></code></a> construct which specifies
columns for descendant mappers of the given base.</p>
<p>Using this method will ensure that each descendant mapper's
tables are included in the FROM clause, and will allow filter()
criterion to be used against those tables.  The resulting
instances will also have those columns already loaded so that
no &quot;post fetch&quot; of those columns will be required.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#with-polymorphic"><span class="std std-ref">Using with_polymorphic</span></a> - full discussion of
<a class="reference internal" href="#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.with_polymorphic()</span></code></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.base">¶</a> -- Base class to be aliased.</li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.classes"></span><strong>classes</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.classes">¶</a> -- a single class or mapper, or list of
class/mappers, which inherit from the base class.
Alternatively, it may also be the string <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, in which case
all descending mapped classes will be added to the FROM clause.</li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.aliased"></span><strong>aliased</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.aliased">¶</a> -- when True, the selectable will be wrapped in an
alias, that is <code class="docutils literal notranslate"><span class="pre">(SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">&lt;fromclauses&gt;)</span> <span class="pre">AS</span> <span class="pre">anon_1</span></code>.
This can be important when using the with_polymorphic()
to create the target of a JOIN on a backend that does not
support parenthesized joins, such as SQLite and older
versions of MySQL.   However if the
<a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.with_polymorphic.params.selectable" title="sqlalchemy.orm.query.Query.with_polymorphic"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">with_polymorphic.selectable</span></code></a> parameter is in use
with an existing <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> construct, then you should not
set this flag.</li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.flat"></span><strong>flat</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.flat">¶</a> -- <p>Boolean, will be passed through to the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias" title="sqlalchemy.sql.expression.FromClause.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FromClause.alias()</span></code></a> call so that aliases of <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Join" title="sqlalchemy.sql.expression.Join"><code class="xref py py-class docutils literal notranslate"><span class="pre">Join</span></code></a>
objects don't include an enclosing SELECT.  This can lead to more
efficient queries in many circumstances.  A JOIN against a nested JOIN
will be rewritten as a JOIN against an aliased SELECT subquery on
backends that don't support this syntax.</p>
<p>Setting <code class="docutils literal notranslate"><span class="pre">flat</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code> implies the <code class="docutils literal notranslate"><span class="pre">aliased</span></code> flag is
also <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 0.9.0에 추가.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Join.alias" title="sqlalchemy.sql.expression.Join.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Join.alias()</span></code></a></p>
</div>
</li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.selectable"></span><strong>selectable</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.selectable">¶</a> -- a table or select() statement that will
be used in place of the generated FROM clause. This argument is
required if any of the desired classes use concrete table
inheritance, since SQLAlchemy currently cannot generate UNIONs
among tables automatically. If used, the <code class="docutils literal notranslate"><span class="pre">selectable</span></code> argument
must represent the full set of tables and columns mapped by every
mapped class. Otherwise, the unaccounted mapped columns will
result in their table being appended directly to the FROM clause
which will usually lead to incorrect results.</li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.polymorphic_on"></span><strong>polymorphic_on</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.polymorphic_on">¶</a> -- a column to be used as the &quot;discriminator&quot;
column for the given selectable. If not given, the polymorphic_on
attribute of the base classes' mapper will be used, if any. This
is useful for mappings that don't have polymorphic loading
behavior by default.</li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.innerjoin"></span><strong>innerjoin</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.innerjoin">¶</a> -- if True, an INNER JOIN will be used.  This should
only be specified if querying for one specific subtype only</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.selectin_polymorphic">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">selectin_polymorphic</code><span class="sig-paren">(</span><em>base_cls</em>, <em>classes</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.selectin_polymorphic" title="정의 주소">¶</a></dt>
<dd><p>Indicate an eager load should take place for all attributes
specific to a subclass.</p>
<p>This uses an additional SELECT with IN against all matched primary
key values, and is the per-query analogue to the <code class="docutils literal notranslate"><span class="pre">&quot;selectin&quot;</span></code>
setting on the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.params.polymorphic_load" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.polymorphic_load</span></code></a> parameter.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 1.2에 추가.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><span class="xref std std-ref">inheritance_polymorphic_load</span></p>
</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="constructors.html" class="btn btn-neutral float-right" title="Constructors and Object Initialization" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="loading_relationships.html" class="btn btn-neutral" title="Relationship Loading Techniques" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
      최종 업데이트: 03/04/2019 18:35:14

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.3.0b1',
            LANGUAGE:'ko',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>