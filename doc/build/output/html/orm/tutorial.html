

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ko" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ko" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>객체 관계형 튜토리얼(Object Relational Tutorial) &mdash; SQLAlchemy 1.3.0b1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="Mapper Configuration" href="mapper_config.html" />
    <link rel="prev" title="SQLAlchemy ORM" href="index.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../contents.html" class="icon icon-home"> SQLAlchemy
          

          
          </a>

          
            
            
              <div class="version">
                1.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">SQLAlchemy ORM</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">객체 관계형 튜토리얼(Object Relational Tutorial)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mapper_config.html">Mapper Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="relationships.html">Relationship Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="loading_objects.html">Loading Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="session.html">Using the Session</a></li>
<li class="toctree-l2"><a class="reference internal" href="extending.html">Events and Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/index.html">ORM Extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html">ORM Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core/index.html">SQLAlchemy Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dialects/index.html">Dialects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../errors.html">Error Messages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog/index.html">Changes and Migration</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../contents.html">SQLAlchemy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../contents.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">SQLAlchemy ORM</a> &raquo;</li>
        
      <li>객체 관계형 튜토리얼(Object Relational Tutorial)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/VeranosTech/docs-korean-sqlalchemy//docs-korean/doc/build/orm/tutorial.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="object-relational-tutorial">
<span id="ormtutorial-toplevel"></span><h1>객체 관계형 튜토리얼(Object Relational Tutorial)<a class="headerlink" href="#object-relational-tutorial" title="제목 주소">¶</a></h1>
<p>SQLAlchemy ORM(Object Relational Mapper)은 사용자가 정의한 클래스를 테이터베이스 테이블에, 그 클래스의 인스턴스를 해당 테이블의 행에 결합시키는 메서드를 제공한다. SQLAlchemy는 객체와 그와 관련된 행 사이의 모든 변화를 명확하게 동기화시키는 시스템 즉, <span class="xref std std-term">작업 단위 패턴</span>(unit of work) 시스템을 가지고 있다. 또한 데이터베이스 쿼리를 사용자가 정의한 클래스와 클래스 사이에서 정의된 관계로 표현할 수 있게 하는 시스템도 포함하고 있다.</p>
<p>ORM의 기반이 되는 SQLAlchemy 표현식 언어(expression language)와 ORM은 아주 다르다. <a class="reference internal" href="../core/tutorial.html#sqlexpression-toplevel"><span class="std std-ref">SQL Expression Language Tutorial</span></a>에서 소개할 SQL 표현식 언어는 관계형 데이터 베이스의 원시적인 구조를 직접적으로 나타내지만 ORM은 표현식 언어를 응용한 고수준의(high level) 사용법이라고 할 수 있다.</p>
<p>ORM과 표현식 언어의 사용 패턴에는 같은 점이 있을 수 있지만 둘 사이의 유사점은 겉보기 뿐이다. ORM은 사용자가 정의한 <a class="reference internal" href="../glossary.html#term-domain-model"><span class="xref std std-term">domain model</span></a>의 관점에서 데이터의 내용과 구조에 접근한다. <a class="reference internal" href="../glossary.html#term-domain-model"><span class="xref std std-term">domain model</span></a>은 내부에 감추어진 스토리지 모형을 통해 투명하게 유지 및 갱신된다. 표현식 언어는 이와 반대로 리터럴 스키마와 SQL 표현의 관점에서 접근한다. 표현식 언어는 데이터베이스에서 개별적으로 사용되는 메세지로 구성된다.</p>
<p>ORM만 사용해도 어플리케이션을 성공적으로 구성할 수 있다. 복잡한 경우에는 어플리케이션을 ORM으로 구현한 뒤 특정 데이터베이스와의 상호작용이 필요한 부분에서만 직접적으로 표현식 언어를 사용하기도 한다.</p>
<p>아래의 튜토리얼은 doctest 형식이다. <code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code> 라인은 파이썬 커맨드 프롬프트에 입력할 수 있다는 것을 뜻하고 그 아래의 텍스트는 예상되는 반환 값을 의미한다.</p>
<div class="section" id="version-check">
<h2>버전 확인(Version Check)<a class="headerlink" href="#version-check" title="제목 주소">¶</a></h2>
<p><strong>1.3 버전</strong> 이상의 SQLAlchemy를 사용하고 있는지 확인한다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sqlalchemy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">__version__</span> 
<span class="go">1.3.0</span>
</pre></div>
</div>
</div>
<div class="section" id="connecting">
<h2>연결(Connecting)<a class="headerlink" href="#connecting" title="제목 주소">¶</a></h2>
<p>이 튜로리얼에서 우리는 인메모리(in-memory-only) SQL 데이터베이스를 사용할 것이다. 연결을 위해서 <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>를 사용한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///:memory:&#39;</span><span class="p">,</span> <span class="n">echo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">echo</span></code> 플래그는 SQLAlchemy 로깅을 설정하기 위한 단축어이며 로깅은 파이썬의 표준 <code class="docutils literal notranslate"><span class="pre">logging</span></code> 모듈을 통해서 이루어진다. 이 플래그가 활성화되면 생성되는 모든 SQL을 확인할 수 있다. 만약 이 튜토리얼을 하면서 출력이 적게 나오기를 바란다며 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 설정하면 된다. 이 튜토리얼은 팝업 창 뒤에서 SQL을 구성하므로 우리가 방해받는 일은 없을 것이다. 어떤 SQL이 생성되었는지 확인하려면 &quot;SQL&quot; 링크를 누르기만 하면 된다.</p>
<p><a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>의 반환 값은 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>의 인스턴스로 사용중인 <a class="reference internal" href="../glossary.html#term-dbapi"><span class="xref std std-term">DBAPI</span></a>와 데이터베이스의 세부사항을 처리하는 <span class="xref std std-term">dialect</span>를 통해 적용된 데이터베이스 핵심 인터페이스를 나타낸다. 본 튜토리얼의 경우에는 SQL dialect가 파이썬 내장 <code class="docutils literal notranslate"><span class="pre">sqlite3</span></code> 모듈에 대한 명령을 해석할 것이다.</p>
<div class="sidebar">
<p class="first sidebar-title">지연 컨넥션(Lazy Connecting)</p>
<p class="last"><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>는 <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>에서 반환되었을 때에는 실제로 데이터베이스에 연결을 시도하지 않는다. 실제 연결은 데이터베이스에 대한 작업을 수행하도록 최초로 요청받았을 때 이루어진다.</p>
</div>
<p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine.execute" title="sqlalchemy.engine.Engine.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.execute()</span></code></a> 또는 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine.connect" title="sqlalchemy.engine.Engine.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.connect()</span></code></a>가 최초로 호출되면, <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>은 데이터베이스에 대한 실제 <a class="reference internal" href="../glossary.html#term-dbapi"><span class="xref std std-term">DBAPI</span></a> 연결을 만들고 SQL을 내보내는 데 사용된다. ORM을 사용할 때, 우리는 보통 생성된 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>를 직접적으로 사용하지 않는다. 엔진은 ORM에 의해 내부적으로 사용된다. 이 부분은 곧 살펴볼 것이다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="../core/engines.html#database-urls"><span class="std std-ref">Database Urls</span></a> - <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>로 다양한 데이터베이스에 연결하는 예제 및 관련 정보에 대한 링크를 포함한다.</p>
</div>
</div>
<div class="section" id="declare-a-mapping">
<h2>매핑 선언(Declare a Mapping)<a class="headerlink" href="#declare-a-mapping" title="제목 주소">¶</a></h2>
<p>ORM을 사용할 때 최초 설정 과정은 데이터베이스 테이블을 구성하고 그 테이블에 매핑 될 클래스를 정의하는 것이다. SQLAlchemy에서 이 두 작업은 선언(Declarative)시스템이라는 것을 사용하여 한번에 실행한다. 이 시스템을 쓰면 매핑할 실제 데이터베이스 테이블을 만드는 명령어를 포함하는 클래스를 생성할 수 있다.</p>
<p>선언 시스템으로 만들어지는 클래스는 클래스를 만들때는 실제 테이블과 클래스의 카탈로그를 관리하는 베이스 클래스 관점에서 정의된다. 이 베이스 클래스를 <strong>declarative base class</strong>라고 부른다. 보통은 공통 임포트 모듈에 이 베이스 클래스의 인스턴스 하나를 만든다. 베이스 클래스는 <a class="reference internal" href="extensions/declarative/api.html#sqlalchemy.ext.declarative.declarative_base" title="sqlalchemy.ext.declarative.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a>함수를 사용해서 다음처럼 생성한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="k">import</span> <span class="n">declarative_base</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>
</pre></div>
</div>
<p>일단 베이스 클래스가 있으면 이것에 관한 여러 개의 매핑된 클래스도 정의할 수 있다. 우리는 <code class="docutils literal notranslate"><span class="pre">users</span></code>라는 이름의 테이블부터 만들 것이다. 이 테이블은 이 기능을 사용하는 최종사용자를 위해 기록을 저장한다. <code class="docutils literal notranslate"><span class="pre">User</span></code>라고 불리는 새로운 클래스는 이 테이블을 매핑하는 클래스이다. 이 클래스 내부에서 매핑할 테이블, 테이블 이름 그리고 컬럼의 이름과 자료형에 대한 세부사항을 정의한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;users&#39;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">fullname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">nickname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>       <span class="k">return</span> <span class="s2">&quot;&lt;User(name=&#39;</span><span class="si">%s</span><span class="s2">&#39;, fullname=&#39;</span><span class="si">%s</span><span class="s2">&#39;, nickname=&#39;</span><span class="si">%s</span><span class="s2">&#39;)&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
<span class="gp">... </span>                            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nickname</span><span class="p">)</span>
</pre></div>
</div>
<div class="sidebar">
<p class="first sidebar-title">팁(Tip)</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">User</span></code> 클래스에서 <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code> 메서드를 정의하지만 이는 <strong>선택적인</strong> 부분이다. 우리는이 튜토리얼에서 이를 구현하기 때문에 우리의 예제는 멋지게 형식화 된 <code class="docutils literal notranslate"><span class="pre">User</span></code> 객체를 보여줄 것이다.</p>
</div>
<p>최소한으로 선언 시스템을 사용하는 클래스는 <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code>속성과 기본 키 <a class="footnote-reference" href="#id2" id="id1">[1]</a>가 되는 하나 이상의 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>이 있어야 한다. SQLAlchemy는 클래스가 참조하는 테이블에 대해 어떠한 가정도 하지 않는다. 테이블 이름이나 데이터 타입, 제약 사항에 대한 내장된 관례도 없다. 그렇다고 템플릿이 있어야 하는 것도 아니다. 대신 helper 함수와 mixin 클래스들을 이용해서 자신만의 자동화된 관례를 만들 수 있다. <a class="reference internal" href="extensions/declarative/mixins.html#declarative-mixins"><span class="std std-ref">Mixin and Custom Base Classes</span></a>를 참고하라.</p>
<p>클래스를 구성할 때, 선언 시스템은 모든 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 객체를 <a class="reference internal" href="../glossary.html#term-descriptors"><span class="xref std std-term">descriptors</span></a>라는 파이썬 접근자로 대체한다. 이를 <a class="reference internal" href="../glossary.html#term-instrumentation"><span class="xref std std-term">instrumentation</span></a>이라고 한다. 매핑된 “instrumented” 클래스는 SQL 컨텍스트에서 테이블을 참조하여 컬럼 값을 불러오고 유지할 수 있는 메서드를 제공한다.</p>
<p>매핑 과정에 클래스에 가해지는 작업만 제외하면 이 클래스는 일반적인 파이썬 클래스와 같으므로 이 클래스에 우리의 어플리케이션에서 필요한 다른 메서드와 속성도 정의할 수 있다.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>기본 키가 왜 요구되는지에 대해서는 <a class="reference internal" href="../faq/ormconfiguration.html#faq-mapper-primary-key"><span class="std std-ref">How do I map a table that has no primary key?</span></a>를 참고하라.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="create-a-schema">
<h2>스키마 생성(Create a Schema)<a class="headerlink" href="#create-a-schema" title="제목 주소">¶</a></h2>
<p>선언 시스템을 통해 생성된 <code class="docutils literal notranslate"><span class="pre">User</span></code> 클래스로 테이블에 대한 정보(<span class="xref std std-term">table metadata</span>)를 정의할 수 있었다. 특정 테이블에 대한 실제 데이터는 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 객체로 표현되는데 SQLAlchemy는 이 객체를 자동 생성한다. 이 객체는 클래스의 <code class="docutils literal notranslate"><span class="pre">__table__</span></code> 속성을 통해 확인할 수 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">User</span><span class="o">.</span><span class="n">__table__</span> 
<span class="go">Table(&#39;users&#39;, MetaData(bind=None),</span>
<span class="go">            Column(&#39;id&#39;, Integer(), table=&lt;users&gt;, primary_key=True, nullable=False),</span>
<span class="go">            Column(&#39;name&#39;, String(), table=&lt;users&gt;),</span>
<span class="go">            Column(&#39;fullname&#39;, String(), table=&lt;users&gt;),</span>
<span class="go">            Column(&#39;nickname&#39;, String(), table=&lt;users&gt;), schema=None)</span>
</pre></div>
</div>
<div class="sidebar">
<p class="first sidebar-title">클래식 맵핑(Classical Mapping)</p>
<p class="last">선언 시스템을 사용하는 것을 적극 추천하지만 SQLAlchemy의 ORM 사용에서 필수적인 것은 아니다. 덜 사용하는 방법이긴 하지만 선언시스템 외에 일반 파이썬 클래스에 <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapper()</span></code></a> 함수를 사용하여 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>로 맵핑할 수도 있다. 이 방법은 클래식 매핑(<a class="reference internal" href="mapping_styles.html#classical-mapping"><span class="std std-ref">Classical Mappings</span></a>)에서 설명한다.</p>
</div>
<p>선언 시스템은 일단 클래스 선언이 완료되면 추가적인 작동을 수행하기 위해 파이썬 메타클래스를 사용한다. 이 때, 설정에 따라 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>객체를 생성하고 그 다음으로 <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code></a> 객체를 생성함으로써 둘을 결합시킨다. <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code></a> 객체는 뒷단에 있는 객체이며 보통 직접 다루지 않는다. (필요한 경우 매핑에 대한 많은 정보를 제공해주기는 한다).</p>
<p><a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 객체는 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>라는 더 큰 집합의 구성원이다. 선언 시스템을 사용한다면 선언용 베이스 클래스의 <code class="docutils literal notranslate"><span class="pre">.metadata</span></code> 속성으로 이 객체에 접근할 수 있다.</p>
<p><a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>는 제한된 수의 스키마 생성 명령어 집합을 데이터베이스로 보내기 위한 기능을 포함하는 레지스트리( <span class="xref std std-term">registry</span>)이다. 현재 우리의 SQLite 데이터베이스는 실제로 <code class="docutils literal notranslate"><span class="pre">users</span></code> 테이블을 가지고 있지 않기 때문에 아직 존재하지 않는 모든 테이블에 대해 CREATE TABLE 명령을 데이터베이스에 내리기위해 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>를 사용할 것이다. 다음 코드에서 보듯이 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.create_all" title="sqlalchemy.schema.MetaData.create_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.create_all()</span></code></a> 메서드를 호출하고 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> 인수를 데이터베이스 연결 소스로서 전달했다. <code class="docutils literal notranslate"><span class="pre">user</span></code> 테이블의 존재를 확인하기 위한 특별 명령이 먼저 발행되고 다음으로 실제 <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> 명령이 전달되는 것을 보게 될 것이다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
<span class="n">SELECT</span> <span class="o">...</span>
<span class="n">PRAGMA</span> <span class="n">table_info</span><span class="p">(</span><span class="s2">&quot;users&quot;</span><span class="p">)</span>
<span class="p">()</span>
<span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">users</span> <span class="p">(</span>
    <span class="nb">id</span> <span class="n">INTEGER</span> <span class="n">NOT</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">,</span>
    <span class="n">fullname</span> <span class="n">VARCHAR</span><span class="p">,</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">,</span>
    <span class="n">PRIMARY</span> <span class="n">KEY</span> <span class="p">(</span><span class="nb">id</span><span class="p">)</span>
<span class="p">)</span>
<span class="p">()</span>
<span class="n">COMMIT</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">테이블 최소 기술(Minimal Description) vs. 전체 기술(Full Description)</p>
<p>CREATE TABLE 문법에 익숙한 사용자는 VARCHAR 컬럼이 길이 제한 없이 생성된 것을 알아차렸을 것이다. 이 방식은 SQLite나 PostegreSQL에서는 유효하지만, 다른 데이터베이스 시스템에서는 그렇지 않다. 따라서 이 튜토리얼을 SQLite나 PostegreSQL가 아닌 다른 데이터베이스에서 실행하는 경우에는 CREATE TABLE 명령을 실행할 때 문자열 길이를 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> 자료형에 다음처럼 제공해야 한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
</pre></div>
</div>
<p><a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>의 length 필드와 <code class="xref py py-class docutils literal notranslate"><span class="pre">Numeric</span></code> 등에서 이용 가능한 precision/scale 필드는 테이블을 생성할 때를 제외하고는 SQLAlchemy에 의해 참조되지 않는다.</p>
<p>추가적으로, Firebird와 Oracle은 새로운 기본 키를 만들 때 시퀀스(sequence)가 필요한데 SQLAlchemy는 명시적 지시없이는 시퀀스를 생성하지 않는다. 시퀀스를 만들려면 <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>를 사용한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Sequence</span>
<span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">(</span><span class="s1">&#39;user_id_seq&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>선언적 매핑을 통해 생성된 전체 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 클래스는 다음과 같다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;users&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">(</span><span class="s1">&#39;user_id_seq&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">nickname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;User(name=&#39;</span><span class="si">%s</span><span class="s2">&#39;, fullname=&#39;</span><span class="si">%s</span><span class="s2">&#39;, nickname=&#39;</span><span class="si">%s</span><span class="s2">&#39;)&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nickname</span><span class="p">)</span>
</pre></div>
</div>
<p>파이썬 내에서만 테이블 클래스를 쓸 때는 이렇게 할 필요가 없지만 여기에서는 더 엄격한 요구사항이 있는 특정 백엔드 데이터베이스에서 CREATE TABLE 명령을 실행할 때를 대비하여 보다 상세한 테이블 정의를 해 보았다.</p>
</div>
</div>
<div class="section" id="create-an-instance-of-the-mapped-class">
<h2>매핑된 클래스의 인스턴스 생성<a class="headerlink" href="#create-an-instance-of-the-mapped-class" title="제목 주소">¶</a></h2>
<p>매핑을 완료했으면, <code class="docutils literal notranslate"><span class="pre">User</span></code> 객체를 생성하고 검사해보자:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ed_user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;edsnickname&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ed_user</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;ed&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ed_user</span><span class="o">.</span><span class="n">nickname</span>
<span class="go">&#39;edsnickname&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">ed_user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="go">&#39;None&#39;</span>
</pre></div>
</div>
<div class="sidebar">
<p class="first sidebar-title"><code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 메서드</p>
<p class="last">선언 시스템을 이용해 정의된 <code class="docutils literal notranslate"><span class="pre">User</span></code> 클래스의 생성자(<code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 메서드)는 자동적으로 우리가 매핑해놓은 컬럼과 일치하는 속성을 가진다. 명시적으로 <code class="docutils literal notranslate"><span class="pre">__init__()</span></code>메서드를 정의할 수도 있다. 이 경우에는 선언 시스템에 의해 제공된 기본 메서드를 덮어쓰게 된다.</p>
</div>
<p>(보통 파이썬에서 정의되지 않은 속성을 사용하면 <code class="docutils literal notranslate"><span class="pre">AttributionError</span></code>가 발생하는 것과 달리) 여기에서는 생성자에서 지정하지 않은 <code class="docutils literal notranslate"><span class="pre">id</span></code> 속성이 자동으로 <code class="docutils literal notranslate"><span class="pre">None</span></code> 값이 된다. SQLAlchemy의 인스트루멘테이션(<a class="reference internal" href="../glossary.html#term-instrumentation"><span class="xref std std-term">instrumentation</span></a>)은 일반적으로 컬럼에 매핑된 속성에 처음 접근했을 때 디폴트 값을 생성한다. 실제로 값이 할당된 속성은 데이터베이스에 보내질 최종적인 INSERT 명령문에서 사용될 수 있도록 인스트루멘테이션 시스템이 계속 추적한다.</p>
</div>
<div class="section" id="creating-a-session">
<h2>세션 생성(Creating a Session)<a class="headerlink" href="#creating-a-session" title="제목 주소">¶</a></h2>
<p>이제 데이터베이스와 대화할 준비가 되었다. 데이터베이스에 대한 ORM의 핸들(handle)은 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>이다. <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>명령으로 처음 어플리케이션을 셋업할 때, <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 객체용 팩토리로 사용할 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 클래스를 정의한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">sessionmaker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
</pre></div>
</div>
<p>만약 어플리케이션에 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>이 없는 경우에는 모듈에서 그냥 다음처럼 설정해도 된다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">()</span>
</pre></div>
</div>
<p>이 때는 나중에 <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>으로 엔진 객체를 만들고 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.sessionmaker.configure" title="sqlalchemy.orm.session.sessionmaker.configure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">configure()</span></code></a>를 사용해서 엔진을 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>에 연결할 수 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Session</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># once engine is available</span>
</pre></div>
</div>
<div class="sidebar">
<p class="first sidebar-title">세션 생애 주기 패턴(Session LifeCycle Patterns)</p>
<p class="last">언제 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>을 만들어야 하는가 하는 질문은 어떤 종류의 어플리케이션을 만들고 있나에 따라 다르다. <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>는 로컬에서 특정한 데이터베이스에 연결하는 객체를 위한 작업 공간일 뿐이라는 점을 명심해라. 만약 어플리케이션 쓰레드를 디너 파티의 게스트라고 생각한다면 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>은 게스트의 접시에 불과하고 클래스가 담고있는 객체가 실제 음식이다! (그리고 데이터베이스는 … 부엌?) 이 주제에 대한 보다 자세한 정보는 <a class="reference internal" href="session_basics.html#session-faq-whentocreate"><span class="std std-ref">When do I construct a Session, when do I commit it, and when do I close it?</span></a>를 참조한다.</p>
</div>
<p>이 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 클래스는 우리의 데이터베이스에 바인딩된 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 객체를 생성한다. 기타 트랜잭션 특성은 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.sessionmaker" title="sqlalchemy.orm.session.sessionmaker"><code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code></a>을 호출할 때 정의된다; 이 부분은 이후의 챕터에서 설명할 것이다. 이제부터는 데이터베이스와 통신 하고 싶을 때마다 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>를 인스턴스화 해야 한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
</pre></div>
</div>
<p>위의 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>은 SQLite <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>과 바인딩되어 있지만 아직 어떠한 연결도 열려있지 않다. 최초로 session을 사용할 때 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>에 의해 유지된 컨넥션 풀에서 컨넥션을 획득하여 모든 변경사항을 커밋하고 session 객체를 닫기 전까지 연결을 유지한다.</p>
</div>
<div class="section" id="adding-and-updating-objects">
<h2>객체의 추가 및 갱신(Adding and Updating Objects)<a class="headerlink" href="#adding-and-updating-objects" title="제목 주소">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">User</span></code> 객체를 영구보존하기 위해서, <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>에 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.add" title="sqlalchemy.orm.session.Session.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a>로 객체를 추가한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ed_user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;edsnickname&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ed_user</span><span class="p">)</span>
</pre></div>
</div>
<p>이 시점에서 우리는 인스턴스가 <strong>pending</strong> 상태라고 한다; SQL은 아직 출력되지 않았으며 객체는 아직 데이터베이스의 행으로 나타나지 않았다. <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>는 필요한 경우 <strong>flush</strong> 라는 과정을 통해 즉시 <code class="docutils literal notranslate"><span class="pre">Ed</span> <span class="pre">Jones</span></code>를 데이터베이스에 입력하는 SQL을 생성한다. 만약 데이터베이스에 <code class="docutils literal notranslate"><span class="pre">Ed</span> <span class="pre">Jones</span></code>를 쿼리한다면 먼저 대기중인 정보가 데이터베이스에 입력되고 그 다음에야 쿼리가 실행된다.</p>
<p>예를 들어, 다음처럼 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> 객체를 사용하여 <code class="docutils literal notranslate"><span class="pre">User</span></code>의 인스턴스를 불러올 수 있다. <code class="docutils literal notranslate"><span class="pre">ed</span></code>의 <code class="docutils literal notranslate"><span class="pre">name</span></code> 속성으로 필터링된 결과에서 첫 번째 것만 받아오도록 했다. 이렇게 하면 우리가 추가했던 것과 똑같은 <code class="docutils literal notranslate"><span class="pre">User</span></code> 인스턴스가 반환된다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">our_user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span> <span class="c1"># doctest:+NORMALIZE_WHITESPACE</span>
<span class=" -Sql -Sql-Popup">BEGIN (implicit)</span>
<span class=" -Sql -Sql-Popup">INSERT INTO users (name, fullname, nickname) VALUES (?, ?, ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;ed&#39;, &#39;Ed Jones&#39;, &#39;edsnickname&#39;)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name = ?</span>
<span class=" -Sql -Sql-Popup"> LIMIT ? OFFSET ?</span>
<span class=" -Sql -Sql-Popup">(&#39;ed&#39;, 1, 0)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">our_user</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;edsnickname&#39;</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>사실 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>는 반환할 행이 객체의 내부 맵에 있는 것과 <strong>동일한</strong> 행이라는 것을 알고 있다. 그래서 우리는 실제로 우리가 추가한 것과 동일한 인스턴스를 돌려 받게 된다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ed_user</span> <span class="ow">is</span> <span class="n">our_user</span>
<span class="go">True</span>
</pre></div>
</div>
<p>여기서 동작하는 ORM 개념은 <a class="reference internal" href="../glossary.html#term-identity-map"><span class="xref std std-term">identity map</span></a>이다. identity map은 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 세션에 있는 특정 행에 대한 모든 작업이 같은 데이터 셋에서 작동함을 보장한다. 일단 특정한 기본 키가 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>에 있으면 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>의 모든 SQL 쿼리는 항상 특정한 기본 키에 대해 동일한 파이썬 객체를 반환한다. 또한 세션 내에서 동일한 기본 키를 이미 보유중인 두 번째 객체를 배치하려고 시도하면 에러가 발생한다.</p>
<p><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.add_all" title="sqlalchemy.orm.session.Session.add_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_all()</span></code></a>를 이용해서 <code class="docutils literal notranslate"><span class="pre">User</span></code> 객체를 한 번에 추가할 수 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">add_all</span><span class="p">([</span>
<span class="o">...</span>     <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;windy&#39;</span><span class="p">),</span>
<span class="o">...</span>     <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Mary Contrary&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">),</span>
<span class="o">...</span>     <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fred&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Fred Flintstone&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;freddy&#39;</span><span class="p">)])</span>
</pre></div>
</div>
<p>또한 Ed의 닉네임이 별로 좋지 않다고 생각한다면 다음처럼 바꿀 수 있다.:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">ed_user</span><span class="o">.</span><span class="n">nickname</span> <span class="o">=</span> <span class="s1">&#39;eddie&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>는 계속 변경 추적을 한다. 예를 들어, 세션은 <code class="docutils literal notranslate"><span class="pre">Ed</span> <span class="pre">Jones</span></code>가 변경됐다는 것을 안다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">dirty</span>
<span class="n">IdentitySet</span><span class="p">([</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;eddie&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">])</span>
</pre></div>
</div>
<p>그리고 새로운 3개의 <code class="docutils literal notranslate"><span class="pre">User</span></code> 객체가 대기중이라는 것도 알고 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">new</span>  <span class="c1"># doctest: +SKIP</span>
<span class="n">IdentitySet</span><span class="p">([</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;windy&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Mary Contrary&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fred&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Fred Flintstone&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;freddy&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">])</span>
</pre></div>
</div>
<p><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.commit" title="sqlalchemy.orm.session.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commit()</span></code></a> 명령을 사용하면 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>에 모든 남아있는 변경 사항을 수정하는 트랜잭션을 커밋한다. 실제로 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>가 “ed”의 닉네임을 변경하는 <code class="docutils literal notranslate"><span class="pre">UPDATE</span></code> 명령과, 추가한 3개의 새로운 <code class="docutils literal notranslate"><span class="pre">User</span></code> 객체를 삽입하는 <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> 명령을 내보내는 것을 볼 수 있다.:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">UPDATE users SET nickname=? WHERE users.id = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;eddie&#39;, 1)</span>
<span class=" -Sql -Sql-Popup">INSERT INTO users (name, fullname, nickname) VALUES (?, ?, ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;wendy&#39;, &#39;Wendy Williams&#39;, &#39;windy&#39;)</span>
<span class=" -Sql -Sql-Popup">INSERT INTO users (name, fullname, nickname) VALUES (?, ?, ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;mary&#39;, &#39;Mary Contrary&#39;, &#39;mary&#39;)</span>
<span class=" -Sql -Sql-Popup">INSERT INTO users (name, fullname, nickname) VALUES (?, ?, ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;fred&#39;, &#39;Fred Flintstone&#39;, &#39;freddy&#39;)</span>
<span class=" -Sql -Sql-Popup">COMMIT</span>
</pre></div>
</div>
<p><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.commit" title="sqlalchemy.orm.session.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commit()</span></code></a>은 남아있는 변경 사항을 데이터베이스로 보내고 트랜잭션을 커밋한다. 작업이 끝나면 세션에 의해 참조된 컨넥션 리소스는 연결 풀로 반환된다. 이 세션을 사용하여 또다른 작업을 하면 새로운 트랜잭션 안에서 실행되고 컨넥션 리소스도 필요한 시점에 다시 획득한다.</p>
<p>이전에 <code class="docutils literal notranslate"><span class="pre">None</span></code>이었던 Ed 의 <code class="docutils literal notranslate"><span class="pre">id</span></code> 속성은 이제 값을 가지고 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">ed_user</span><span class="o">.</span><span class="n">id</span> <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
<span class=" -Sql -Sql-Popup">BEGIN (implicit)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = ?</span>
<span class=" -Sql -Sql-Popup">(1,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="mi">1</span>
</pre></div>
</div>
<p><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>가 데이터베이스에 새로운 행을 삽입하면 인스턴스에서 새롭게 생성된 식별자들과 데이터베이스 생성 기본 값이 즉시 혹은 최초로 접근할 때 준비된다. 이 때에는 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.commit" title="sqlalchemy.orm.session.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commit()</span></code></a>을 실행한 뒤에 새로운 트랜잭션이 시작되었기 때문에 전체 행이 다시 로드된다. SQLAlchemy는 기본적으로 이전 트랜잭션으로부터 얻은 데이터를 새로운 트랜잭션에서 사용할 때는 다시 데이터를 리로드(reload)해서 가장 최신 데이터를 이용할 수 있게 해준다. 리로드 수준은 <a class="reference internal" href="session.html"><span class="doc">Using the Session</span></a>에서 설명하는대로 조정할 수 있다.</p>
<div class="topic">
<p class="topic-title first">세션 객체의 상태(Session Object States)</p>
<p><code class="docutils literal notranslate"><span class="pre">User</span></code> 객체가 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 밖에서, <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 안으로 기본 키 없이 이동하면서 삽입되었고, 4가지 중 3가지의 가능한 “객체 상태” (<strong>임시(transient)</strong>, <strong>대기(pending)</strong>, <strong>영속(persistent)</strong>) 사이에서 움직였다. 이 상태들과 그 의미를 알고 있는 것은 도움이 되므로 <a class="reference internal" href="session_state_management.html#session-object-states"><span class="std std-ref">Quickie Intro to Object States</span></a>에 있는 간단한 설명을 읽어 보기 바란다.</p>
</div>
</div>
<div class="section" id="rolling-back">
<h2>롤백 하기(Rolling Back)<a class="headerlink" href="#rolling-back" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>은 트랜잭션 내에서 작동하기 때문에 변경한 것을 롤백할 수도 있다. 되돌릴 변경 사항 두 개를 만들어보자; <code class="docutils literal notranslate"><span class="pre">ed_user</span></code>의 사용자 이름을 <code class="docutils literal notranslate"><span class="pre">Edwardo</span></code>로 설정한다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">ed_user</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Edwardo&#39;</span>
</pre></div>
</div>
<p>그리고 잘못 입력된 사용자, <code class="docutils literal notranslate"><span class="pre">fake_user</span></code>를 추가한다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">fake_user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fakeuser&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Invalid&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;12345&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fake_user</span><span class="p">)</span>
</pre></div>
</div>
<p>세션으로 쿼리를 하면, 변경 사항이 현재의 트랜잭션으로 들어간 것을 확인할 수 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;Edwardo&#39;</span><span class="p">,</span> <span class="s1">&#39;fakeuser&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">UPDATE users SET name=? WHERE users.id = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;Edwardo&#39;, 1)</span>
<span class=" -Sql -Sql-Popup">INSERT INTO users (name, fullname, nickname) VALUES (?, ?, ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;fakeuser&#39;, &#39;Invalid&#39;, &#39;12345&#39;)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name IN (?, ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;Edwardo&#39;, &#39;fakeuser&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Edwardo&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;eddie&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fakeuser&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Invalid&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;12345&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<p>롤백하면, <code class="docutils literal notranslate"><span class="pre">ed_user</span></code>의 이름이 <code class="docutils literal notranslate"><span class="pre">ed</span></code>로 돌아가고 <code class="docutils literal notranslate"><span class="pre">fake_user</span></code>가 세션에서 사라지는 것을 확인할 수 있다.</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">ROLLBACK</span>
<span class=" -Sql -Sql-Popup">{stop}</span>

<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">ed_user</span><span class="o">.</span><span class="n">name</span>
<span class=" -Sql -Sql-Popup">BEGIN (implicit)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = ?</span>
<span class=" -Sql -Sql-Popup">(1,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="sa">u</span><span class="s1">&#39;ed&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fake_user</span> <span class="ow">in</span> <span class="n">session</span>
<span class="bp">False</span>
</pre></div>
</div>
<p>SELECT를 이용하면 데이터베이스에서 생성된 변경 사항을 볼 수 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="s1">&#39;fakeuser&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name IN (?, ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;ed&#39;, &#39;fakeuser&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;eddie&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="querying">
<span id="ormtutorial-querying"></span><h2>쿼리하기(Querying)<a class="headerlink" href="#querying" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> 객체는 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>의 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.query" title="sqlalchemy.orm.session.Session.query"><code class="xref py py-class docutils literal notranslate"><span class="pre">query()</span></code></a> 메서드를 사용해 생성할 수 있다. 이 함수는 어떤 클래스와 클래스 인스트루먼트 디스크립터의 조합도 인수로 넣을 수 있고 인수의 갯수도 상관없다. 아래는 <code class="docutils literal notranslate"><span class="pre">User</span></code> 인스턴스를 불러오는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>다. 이 객체를 iteration 컨텍스트에서 evaluation하면, 모든 <code class="docutils literal notranslate"><span class="pre">User</span></code> 객체의 리스트를 반환한다.</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users ORDER BY users.id</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="n">ed</span> <span class="n">Ed</span> <span class="n">Jones</span>
<span class="n">wendy</span> <span class="n">Wendy</span> <span class="n">Williams</span>
<span class="n">mary</span> <span class="n">Mary</span> <span class="n">Contrary</span>
<span class="n">fred</span> <span class="n">Fred</span> <span class="n">Flintstone</span>
</pre></div>
</div>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>는 인수로 ORM 인스트루먼트 디스크립터도 받을 수 있다. 다중 클래스 엔티티나 컬럼 기반 엔티티가 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.query" title="sqlalchemy.orm.session.Session.query"><code class="xref py py-class docutils literal notranslate"><span class="pre">query()</span></code></a>에 인수로 전달되면 반환 결과는 튜플로 나타난다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">fullname</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="n">ed</span> <span class="n">Ed</span> <span class="n">Jones</span>
<span class="n">wendy</span> <span class="n">Wendy</span> <span class="n">Williams</span>
<span class="n">mary</span> <span class="n">Mary</span> <span class="n">Contrary</span>
<span class="n">fred</span> <span class="n">Fred</span> <span class="n">Flintstone</span>
</pre></div>
</div>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>로 반환되는 튜플은 <em>명명된</em> 튜플이며, <a class="reference internal" href="query.html#sqlalchemy.util.KeyedTuple" title="sqlalchemy.util.KeyedTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyedTuple</span></code></a>클래스로 제공되고 일반 파이썬 객체처럼 다루어진다. 속성의 속성 이름과, 클래스의 클래스 이름은 동일하다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
<span class="o">...</span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">User</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;eddie&#39;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ed</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;windy&#39;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">wendy</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Mary Contrary&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mary</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fred&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Fred Flintstone&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;freddy&#39;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">fred</span>
</pre></div>
</div>
<p>개별 컬럼 표현식의 이름은 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label" title="sqlalchemy.sql.expression.ColumnElement.label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">label()</span></code></a> 구조를 사용해 조정할 수 있으며 이 구조는 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a> 파생 객체와 하나의 클래스에 맵핑된 클래스 속성(예, <code class="docutils literal notranslate"><span class="pre">User.name</span></code>)에서 사용할 수 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;name_label&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
<span class="o">...</span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">name_label</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.name AS name_label</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">(){stop}</span>
<span class="n">ed</span>
<span class="n">wendy</span>
<span class="n">mary</span>
<span class="n">fred</span>
</pre></div>
</div>
<p><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.query" title="sqlalchemy.orm.session.Session.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> 호출할 때 복수의 엔티티가 있는 경우에는 <code class="docutils literal notranslate"><span class="pre">User</span></code> 같은 전체 엔티티에 주어진 이름을 <a class="reference internal" href="query.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a>를 사용해 제어할 수 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">aliased</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">user_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;user_alias&#39;</span><span class="p">)</span>

<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">user_alias</span><span class="p">,</span> <span class="n">user_alias</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
<span class="o">...</span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">user_alias</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT user_alias.id AS user_alias_id,</span>
<span class=" -Sql -Sql-Popup">        user_alias.name AS user_alias_name,</span>
<span class=" -Sql -Sql-Popup">        user_alias.fullname AS user_alias_fullname,</span>
<span class=" -Sql -Sql-Popup">        user_alias.nickname AS user_alias_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users AS user_alias</span>
<span class=" -Sql -Sql-Popup">(){stop}</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;eddie&#39;</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;windy&#39;</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Mary Contrary&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fred&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Fred Flintstone&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;freddy&#39;</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>파이썬 배열 슬라이싱을 써서 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>에 LIMIT과 OFFSET 옵션을 포함시킬 수 있고 ORDER BY와 함께 쓸 수도 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]:</span>
<span class="o">...</span>    <span class="k">print</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users ORDER BY users.id</span>
<span class=" -Sql -Sql-Popup">LIMIT ? OFFSET ?</span>
<span class=" -Sql -Sql-Popup">(2, 1){stop}</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;windy&#39;</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Mary Contrary&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.filter_by" title="sqlalchemy.orm.query.Query.filter_by"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter_by()</span></code></a>에 키워드 인수를 넣어 결과를 필터링할 수도 있다.:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>             <span class="n">filter_by</span><span class="p">(</span><span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">):</span>
<span class="o">...</span>    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.name AS users_name FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.fullname = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;Ed Jones&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="n">ed</span>
</pre></div>
</div>
<p>더 유연한 SQL 표현식 언어 구조를 사용하는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.filter" title="sqlalchemy.orm.query.Query.filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a>를 사용할 수도 있다. 이 경우 매핑된 클래스의 클래스 수준 속성과 함께 일반 파이썬 연산자도 쓸 수 있다.:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>             <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="o">==</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">):</span>
<span class="o">...</span>    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.name AS users_name FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.fullname = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;Ed Jones&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="n">ed</span>
</pre></div>
</div>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> 객체는 완전히 <strong>생성적(generative)</strong> 이다. 즉, 대부분의 메서드 호출 결과는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> 객체로 반환된다. 따라서 다음처럼 조건을 더 추가시킬 수 있다. 예를 들어 전체 이름이 “Ed Jones”고 이름이 “ed”인 사용자를 쿼리하고 싶으면, <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.filter" title="sqlalchemy.orm.query.Query.filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a>를 두 번 호출하면 되며, 조건은 <code class="docutils literal notranslate"><span class="pre">AND</span></code>를 사용하여 결합된다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>          <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>          <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="o">==</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">):</span>
<span class="o">...</span>    <span class="k">print</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name = ? AND users.fullname = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;ed&#39;, &#39;Ed Jones&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;eddie&#39;</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="section" id="common-filter-operators">
<h3>자주 쓰이는 필터 연산자(Common Filters Operators)<a class="headerlink" href="#common-filter-operators" title="제목 주소">¶</a></h3>
<p>아래는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.filter" title="sqlalchemy.orm.query.Query.filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a> 에서 가장 일반적으로 쓰이는 연산자 목록이다:</p>
<ul>
<li><p class="first"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.__eq__" title="sqlalchemy.sql.operators.ColumnOperators.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">equals</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.__ne__" title="sqlalchemy.sql.operators.ColumnOperators.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">not</span> <span class="pre">equals</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like" title="sqlalchemy.sql.operators.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LIKE</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like" title="sqlalchemy.sql.operators.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.like()</span></code></a>는 LIKE 연산자를 렌더링하며,몇몇 백엔드에서는 대소문자를 구별하지 않고, 몇몇 백엔드에서는 대소문자를 구별한다. 대소문자를 구별하지 않는 비교를 하려면 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.ilike" title="sqlalchemy.sql.operators.ColumnOperators.ilike"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.ilike()</span></code></a>를 사용하라.</p>
</div>
</div></blockquote>
<ul>
<li><p class="first"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.ilike" title="sqlalchemy.sql.operators.ColumnOperators.ilike"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ILIKE</span></code></a> (case-insensitive LIKE):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">ilike</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">대부분의 백엔드는 ILIKE를 직접적으로 지원하지 않는다. 그런 경우 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.ilike" title="sqlalchemy.sql.operators.ColumnOperators.ilike"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.ilike()</span></code></a> 연산자는 LIKE를 각 피연산자에 적용된 하위 레벨 SQL 함수와 결합한 표현으로 렌더링한다.</p>
</div>
</div></blockquote>
<ul>
<li><p class="first"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.in_" title="sqlalchemy.sql.operators.ColumnOperators.in_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IN</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;jack&#39;</span><span class="p">]))</span>

<span class="c1"># works with query objects too:</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span>
<span class="p">))</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.notin_" title="sqlalchemy.sql.operators.ColumnOperators.notin_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">IN</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">~</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;jack&#39;</span><span class="p">]))</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.is_" title="sqlalchemy.sql.operators.ColumnOperators.is_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IS</span> <span class="pre">NULL</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># alternatively, if pep8/linters are a concern</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">is_</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.isnot" title="sqlalchemy.sql.operators.ColumnOperators.isnot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IS</span> <span class="pre">NOT</span> <span class="pre">NULL</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># alternatively, if pep8/linters are a concern</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">isnot</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.and_" title="sqlalchemy.sql.expression.and_"><code class="xref py py-func docutils literal notranslate"><span class="pre">AND</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># use and_()</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">and_</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">and_</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span> <span class="o">==</span> <span class="s1">&#39;Ed Jones&#39;</span><span class="p">))</span>

<span class="c1"># or send multiple expressions to .filter()</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span> <span class="o">==</span> <span class="s1">&#39;Ed Jones&#39;</span><span class="p">)</span>

<span class="c1"># or chain multiple filter()/filter_by() calls</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">fullname</span> <span class="o">==</span> <span class="s1">&#39;Ed Jones&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">파이썬 <code class="docutils literal notranslate"><span class="pre">and</span></code> 연산자가 <strong>아니라</strong> <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.and_" title="sqlalchemy.sql.expression.and_"><code class="xref py py-func docutils literal notranslate"><span class="pre">and_()</span></code></a>를 사용하고 있는지 확인하라.</p>
</div>
</div></blockquote>
<ul>
<li><p class="first"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.or_" title="sqlalchemy.sql.expression.or_"><code class="xref py py-func docutils literal notranslate"><span class="pre">OR</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">or_</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">or_</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;wendy&#39;</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">파이썬 <code class="docutils literal notranslate"><span class="pre">or</span></code> 연산자가 아니라 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.or_" title="sqlalchemy.sql.expression.or_"><code class="xref py py-func docutils literal notranslate"><span class="pre">or_()</span></code></a>를 사용하고 있는지 확인하라.</p>
</div>
</div></blockquote>
<ul>
<li><p class="first"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.match" title="sqlalchemy.sql.operators.ColumnOperators.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MATCH</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;wendy&#39;</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.match" title="sqlalchemy.sql.operators.ColumnOperators.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>는 특정 데이터베이스만 제공하는 <code class="docutils literal notranslate"><span class="pre">MATCH</span></code> 명령이나 <code class="docutils literal notranslate"><span class="pre">CONTAINS</span></code> 함수를 사용한다. 이 동작은 백엔드에 따라 다르며, SQLite 같은 몇몇 백엔드에서는 사용할 수 없다.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="returning-lists-and-scalars">
<h3>리스트와 스칼라 반환(Returning Lists and Scalars<a class="headerlink" href="#returning-lists-and-scalars" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>의 메서드 대부분은 즉시 SQL을 출력하고 로드된 데이터베이스 결과를 포함하는 값을 반환한다. 아래는 간단한 예시이다:</p>
<ul>
<li><p class="first"><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.all" title="sqlalchemy.orm.query.Query.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a>는 리스트를 반환한다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name LIKE ? ORDER BY users.id</span>
<span class=" -Sql -Sql-Popup">(&#39;%ed&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;eddie&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fred&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Fred Flintstone&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;freddy&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.first" title="sqlalchemy.orm.query.Query.first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first()</span></code></a>는 limit를 하나로 정하여 첫 번째 결과만 스칼라로 반환한다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">query</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name LIKE ? ORDER BY users.id</span>
<span class=" -Sql -Sql-Popup"> LIMIT ? OFFSET ?</span>
<span class=" -Sql -Sql-Popup">(&#39;%ed&#39;, 1, 0)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;eddie&#39;</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.one" title="sqlalchemy.orm.query.Query.one"><code class="xref py py-meth docutils literal notranslate"><span class="pre">one()</span></code></a>는 모든 행을 완전히 불러오고, 정확한 객체 행이나 복합 객체 행이 결과에 존재하지 않으면 에러를 발생시킨다. 여러 행이 찾아진 경우:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="o">...</span>
<span class="n">MultipleResultsFound</span><span class="p">:</span> <span class="n">Multiple</span> <span class="n">rows</span> <span class="n">were</span> <span class="n">found</span> <span class="k">for</span> <span class="n">one</span><span class="p">()</span>
</pre></div>
</div>
<p>찾아진 행이 없는 경우:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">99</span><span class="p">)</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="o">...</span>
<span class="n">NoResultFound</span><span class="p">:</span> <span class="n">No</span> <span class="n">row</span> <span class="n">was</span> <span class="n">found</span> <span class="k">for</span> <span class="n">one</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.one" title="sqlalchemy.orm.query.Query.one"><code class="xref py py-meth docutils literal notranslate"><span class="pre">one()</span></code></a> 메서드는 &quot;no items found&quot;와 &quot;multiple items found&quot;를 다르게 처리하기 원하는 시스템에 쓸모가 있다; 예를 들어, 찾은 결과가 하나도 없을 때는 &quot;404 not found&quot;를 발생키길 원하고 찾은 결과가 하나이면 어플리케이션 에러를 발생시키기 원하는 RESTful 웹서비스를 만들 때 유용하다.</p>
</li>
<li><p class="first"><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.one_or_none" title="sqlalchemy.orm.query.Query.one_or_none"><code class="xref py py-meth docutils literal notranslate"><span class="pre">one_or_none()</span></code></a>는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.one" title="sqlalchemy.orm.query.Query.one"><code class="xref py py-meth docutils literal notranslate"><span class="pre">one()</span></code></a>와 비슷하지만,결과를 찾지 못했을 때 에러를 발생시키지 않고 그냥 <code class="docutils literal notranslate"><span class="pre">None</span></code> 값을 반환한다.그러나, <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.one" title="sqlalchemy.orm.query.Query.one"><code class="xref py py-meth docutils literal notranslate"><span class="pre">one()</span></code></a> 처럼여러 결과를 찾았을 경우 에러를 발생시킨다.</p>
</li>
<li><p class="first"><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.scalar" title="sqlalchemy.orm.query.Query.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a>는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.one" title="sqlalchemy.orm.query.Query.one"><code class="xref py py-meth docutils literal notranslate"><span class="pre">one()</span></code></a> 메서드를 불러오며, 성공시에 행의 첫 번째 컬럼을 반환한다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>    <span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">query</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name = ? ORDER BY users.id</span>
<span class=" -Sql -Sql-Popup">(&#39;ed&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="mi">1</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="using-textual-sql">
<span id="orm-tutorial-literal-sql"></span><h3>텍스트형 SQL 사용하기(Using Textual SQL)<a class="headerlink" href="#using-textual-sql" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> 생성자를 사용하면 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>에서 리터럴 스트링을 쓸 수 있다. <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.filter" title="sqlalchemy.orm.query.Query.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>와 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.order_by" title="sqlalchemy.orm.query.Query.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code></a>를 포함한 대부분의 메서드에 적용 가능하다.</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">text</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>             <span class="nb">filter</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;id&lt;224&quot;</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span>             <span class="n">order_by</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE id&lt;224 ORDER BY id</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="n">ed</span>
<span class="n">wendy</span>
<span class="n">mary</span>
<span class="n">fred</span>
</pre></div>
</div>
<p>바인드 파라미터(bind parameter)는 콜론을 써서 스트링 기반 SQL로 지정할 수 있다. 이 때는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.params" title="sqlalchemy.orm.query.Query.params"><code class="xref py py-meth docutils literal notranslate"><span class="pre">params()</span></code></a> 메서드로 값을 지정한다.:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;id&lt;:value and name=:name&quot;</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span>     <span class="n">params</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fred&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE id&lt;? and name=? ORDER BY users.id</span>
<span class=" -Sql -Sql-Popup">(224, &#39;fred&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fred&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Fred Flintstone&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;freddy&#39;</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>명령 전체를 감싸는 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> 생성자를 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.from_statement" title="sqlalchemy.orm.query.Query.from_statement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_statement()</span></code></a>에 전달하면 순수한 SQL 명령 문자열을 쓸 수 있다. 추가적인 지정자가 없어도 SQL 문자열에 있는 컬럼은 해당 이름에 기반한 모델 컬럼과 매치된다. 예를 들어 아래에서는 별표를 사용하여 모든 컬럼을 로드하였다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">from_statement</span><span class="p">(</span>
<span class="o">...</span>                     <span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM users where name=:name&quot;</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span>                     <span class="n">params</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT * FROM users where name=?</span>
<span class=" -Sql -Sql-Popup">(&#39;ed&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;eddie&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<p>간단한 경우에는 테이블 컬럼과 문자열 내의 이름이 일치하지만 중복된 컬럼 이름을 포함하는 복잡한 명령을 처리하거나 특정 이름과 쉽게 일치하지 않는 익명화된 ORM을 사용할 때는 매칭이 어려워질 수 있다. 또, 결과 행들을 처리할 때 필요하다고 판단되는 매핑된 컬럼에 존재하는 타이핑 동작이 있을 수도 있다. 이 때는 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> 생성자가 텍스트 형식 SQL을 위치에 따라 Core나 ORM-매핑된 컬럼 표현식에 연결해준다. 컬럼 표현식을 위치 인수로 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a>에 전달하면 된다.</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT name, id, fullname, nickname &quot;</span>
<span class="o">...</span>             <span class="s2">&quot;FROM users where name=:name&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">nickname</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">from_statement</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT name, id, fullname, nickname FROM users where name=?</span>
<span class=" -Sql -Sql-Popup">(&#39;ed&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;eddie&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 1.1에 추가: </span><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a> 메서드는 현재 일반 텍스트 SQL 결과 집합에 일치하게 될 컬럼 표현식을 인수의 위치(순서)로 확인하므로 SQL 명령에서 컬럼 이름이 동일하거나 유니크해야 할 필요가 없어졌다.</p>
</div>
<p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>를 써서 쿼리를 할 때도 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>는 여전히 반환될 엔티티와 컬럼을 지정할 수 있다. 다른 경우처럼 <code class="docutils literal notranslate"><span class="pre">query(User)</span></code>를 쓰는 대신에 컬럼을 개별적으로 요청할 수도 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT name, id FROM users where name=:name&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>          <span class="n">from_statement</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT name, id FROM users where name=?</span>
<span class=" -Sql -Sql-Popup">(&#39;ed&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;ed&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="../core/tutorial.html#sqlexpression-text"><span class="std std-ref">Using Textual SQL</span></a> - Core 전용 쿼리 관점에서 설명된 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> 구조.</p>
</div>
</div>
<div class="section" id="counting">
<h3>카운팅(counting)<a class="headerlink" href="#counting" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>는 카운팅을 위한 편리한 메서드인 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.count" title="sqlalchemy.orm.query.Query.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a>을 포함하고 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT count(*) AS count_1</span>
<span class=" -Sql -Sql-Popup">FROM (SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">                users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">                users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">                users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name LIKE ?) AS anon_1</span>
<span class=" -Sql -Sql-Popup">(&#39;%ed&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="mi">2</span>
</pre></div>
</div>
<div class="sidebar">
<p class="first sidebar-title">count()로 카운트하기</p>
<p class="last"><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.count" title="sqlalchemy.orm.query.Query.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.count()</span></code></a>는 서브 쿼리가 기존 쿼리에 필요한지를 추측하려고 할 때는 매우 복잡한 메서드가 됐었고 몇몇 특이한 경우에는 올바르게 작동하지 않았다. 이제 간단한 서브 쿼리를 사용하기 때문에 길이도 두 줄밖에 되지 않고 항상 올바른 답을 반환한다. 특정한 명령이 서브 쿼리가 존재하는 것을 절대 용납하지 않는 경우 <code class="docutils literal notranslate"><span class="pre">func.count()</span></code>를 사용하라.</p>
</div>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.count" title="sqlalchemy.orm.query.Query.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a> 메서드는 SQL 명령이 반환하는 행의 갯수를 알려준다. 위에서 생성된 SQL을 보면 SQLAlchemy는 항상 쿼리 하려는 것을 서브쿼리에 넣고, 그 결과으로부터 행을 센다. 몇몇 경우에는 더 간단한 <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">count(*)</span> <span class="pre">FROM</span> <span class="pre">table</span></code>로 축소될 수도 있다. 그러나, 최신 버전의 SQLAlchemy는 더 명시적인 수단을 사용해서 정확한 SQL을 내보낼 수 있기 때문에 이것이 언제 적헐한지를 추측하지 않는다</p>
<p>특별히 어떤 것을 카운팅해야 하는지 명시해야 하는 경우에는 &quot;count&quot; 함수를 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-attr docutils literal notranslate"><span class="pre">func</span></code></a>에서  <code class="docutils literal notranslate"><span class="pre">func.count()</span></code> 표현을 사용해서 직접 지정할 수 있다. 아래에서는 각각의 user name의 카운트를 반환하기 위해서 사용했다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT count(users.name) AS count_1, users.name AS users_name</span>
<span class=" -Sql -Sql-Popup">FROM users GROUP BY users.name</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;ed&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;fred&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;mary&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;wendy&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>단순한 <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">count(*)</span> <span class="pre">FROM</span> <span class="pre">table</span></code>이 되도록 아래처럼 적용할 수도 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT count(?) AS count_1</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">(&#39;*&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="mi">4</span>
</pre></div>
</div>
<p>만약 <code class="docutils literal notranslate"><span class="pre">User</span></code> 기본 키를 직접 카운트하는 경우에는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.select_from" title="sqlalchemy.orm.query.Query.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_from()</span></code></a> 명령을 쓰지 않아도 된다.:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">))</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT count(users.id) AS count_1</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="mi">4</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="building-a-relationship">
<span id="orm-tutorial-relationship"></span><h2>릴레이션 만들기(Building a Relationship)<a class="headerlink" href="#building-a-relationship" title="제목 주소">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">User</span></code> 테이블과 관련된 두 번째 테이블을 어떻게 매핑하고 쿼리할지 생각해보자. User 테이블은 username과 연결된 이메일 주소를 저장할 수 있다. 이는 <code class="docutils literal notranslate"><span class="pre">User</span></code>에서 이메일 주소를 저장하는 새로운 테이블(<code class="docutils literal notranslate"><span class="pre">addresses</span></code>로 부를 것이다) 로 향하는 기본적인 일대다 결합(one-to-many association)을 의미한다. 선언 시스템을 이용해 매핑된 클래스 <code class="docutils literal notranslate"><span class="pre">Address</span></code>와 함께 이 테이블을 정의한다:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">ForeignKey</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;addresses&#39;</span>
<span class="gp">... </span>    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">email_address</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">user_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;users.id&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">user</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;User&quot;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s2">&quot;&lt;Address(email_address=&#39;</span><span class="si">%s</span><span class="s2">&#39;)&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">email_address</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="n">Address</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>위의 클래스는 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 구조를 소개하고 있다. 이 구조는 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>에 적용하는 명령어로 이 컬럼에 있는 값은 반드시 지명된 외부의 컬럽에 존재하는 값과 <a class="reference internal" href="../glossary.html#term-constrained"><span class="xref std std-term">constrained</span></a> 되어야 한다는 것을 나타낸다. 이것은 관계형 데이터베이스의 핵심 기능 중 하나로, 연결되지 않은 테이블 집합을 오버래핑된 풍부한 관계를 가질 수 있게 변환시켜주는 접착제다. 위의 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">addresses.user_id</span></code> 컬럼에 있는 값은 반드시 <code class="docutils literal notranslate"><span class="pre">users.id</span></code> 컬럼에 있는 값과 묶여있어야 한다는 것을 나타낸다. 즉, 일종의 기본 키다.</p>
<p>두 번째 명령어 <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>는 ORM에게 <code class="docutils literal notranslate"><span class="pre">Address</span></code>자체가 <code class="docutils literal notranslate"><span class="pre">User</span></code> 클래스와 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 속성을 사용해 연결되어야 한다는 것을 말해준다. <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>는 두 테이블 사이의 foreign key 관계를 사용해서 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code>가 <a class="reference internal" href="../glossary.html#term-many-to-one"><span class="xref std std-term">many to one</span></a>이 되도록 하는 연결의 성질을 결정한다. 추가적인 <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 명령어는 매핑된 <code class="docutils literal notranslate"><span class="pre">User</span></code> 클래스의 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> 속성에 위치한다. 두 <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 명령 내에서 <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a> 변수는 상호간에 속성 이름을 참조하기 위해서 할당된다; 그렇게 함으로써 각각의 <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>은 역으로 표현된 것과 같이 동일한 관계에 대한 지능적인 결정을 할 수 있게 된다; 한 쪽에서 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code>가 <code class="docutils literal notranslate"><span class="pre">User</span></code> 인스턴스를 참조하고, 다른 쪽에서 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> 가 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 인스턴스의 리스트를 참조한다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a>는 가장 흔한 QlAlchemy 특징인 <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship.params.backref" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.backref</span></code></a>의 새로운 버전이다. <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship.params.backref" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.backref</span></code></a> 변수는 사라지지 않았으며 앞으로도 사용가능할 것이다. <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a>는 좀 더 상세하고 쉽게 조정할 수 있는 점을 제외하고는 동일하다. 전체 내용에 대한 개요는 <a class="reference internal" href="backref.html#relationships-backref"><span class="std std-ref">Linking Relationships with Backref</span></a> 섹션에서 볼 수 있다.</p>
</div>
<p>다대일 relationship의 반대는 <a class="reference internal" href="../glossary.html#term-one-to-many"><span class="xref std std-term">one to many</span></a>이다.사용가능한 전체 <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 설정은 <a class="reference internal" href="basic_relationships.html#relationship-patterns"><span class="std std-ref">Basic Relationship Patterns</span></a>를 참고하라.</p>
<p>두 보완적인 관계인 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code>와 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code>는 <a class="reference internal" href="../glossary.html#term-bidirectional-relationship"><span class="xref std std-term">bidirectional relationship</span></a>로서 참조되며, 이는 SQLAlchemy ORM의 중요한 핵심적인 기능이다. <a class="reference internal" href="backref.html#relationships-backref"><span class="std std-ref">Linking Relationships with Backref</span></a>에서 &quot;backref&quot; 기능에 대해 자세하게 다루고 있다.</p>
<p>다른 클래스와 연관된 <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>의 인수는 Decalarative system이 사용중이면 문자열을 사용해서 지정할 수 있다. 모든 매핑이 완로되면, 이 문자열들은 실제 인수를 생성하기 위한 파이썬 표현식으로 인식되며 위의 경우에서는 <code class="docutils literal notranslate"><span class="pre">User</span></code> 클래스가 된다. 평가 중에 허용되는 이름은 선언된 base로 생성된 모든 클래스의 이름을 포함한다.</p>
<p>인수 스타일에 대한 더 자세한 정보는 <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>에 관한 독스트링을 참고하라.</p>
<div class="topic">
<p class="topic-title first">Did you know ?</p>
<ul class="simple">
<li>대부분의 관계형 데이터베이스의 FOREIGN KEY 제약은 기본 키 컬럼이나, UNIQUE 제약이 걸려있는 컬럼과만 연결이 가능하다.</li>
<li>여러 기본 키 컬럼을 참조하거나 여러 컬럼을 가지고 있는 FOREIGN KEY 제약은 &quot;composite foreign key&quot;로 알려져 있다. 이 키는 위의 컬럼들의 하위 집합도 참조할 수 있다.</li>
<li>FOREIGN KEY 컬럼은 참초하는 컬럼이나 행의 변와에 따라 자동적으로 자기자신을 업데이트 한다. 이것은 CASCADE <em>referential action</em>으로 알려져있고, 관계형 데이터베이스의 내장 함수다.</li>
<li>FOREIGN KEY는 자신이 속한 테이블을 참조할 수 있다. 이것은 &quot;sefl_referential&quot; foreign key로 알려져 있다.</li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Foreign_key">Foreign Key - Wikipedia</a>에서 foreign key에 대한 더 자세한 내용을 확인할 수 있다.</li>
</ul>
</div>
<p>우리는 데이터베이스에 <code class="docutils literal notranslate"><span class="pre">addresses</span></code> 테이블을 만들어야할 필요가 있다. 그래서 우리의 metadata로부터 또다른 CREATE 명령을 내보낼 것이고, 이 때 이미 생성된 테이블은 알아서 스킵될 것이다.</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">PRAGMA...</span>
<span class=" -Sql -Sql-Popup">CREATE TABLE addresses (</span>
<span class=" -Sql -Sql-Popup">    id INTEGER NOT NULL,</span>
<span class=" -Sql -Sql-Popup">    email_address VARCHAR NOT NULL,</span>
<span class=" -Sql -Sql-Popup">    user_id INTEGER,</span>
<span class=" -Sql -Sql-Popup">    PRIMARY KEY (id),</span>
<span class=" -Sql -Sql-Popup">     FOREIGN KEY(user_id) REFERENCES users (id)</span>
<span class=" -Sql -Sql-Popup">)</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">COMMIT</span>
</pre></div>
</div>
</div>
<div class="section" id="working-with-related-objects">
<h2>관계형 객체로 작업하기(Working with Related Objects)<a class="headerlink" href="#working-with-related-objects" title="제목 주소">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">User</span></code>가 생성될 때, 비어있는 <code class="docutils literal notranslate"><span class="pre">addresses</span></code> 컬렉션이 존재한다. 집합이나 딕셔너리 형태 등의 다양한 컬렉션 타입이 가능하지만 (자세한 내용은 <a class="reference internal" href="collections.html#custom-collections"><span class="std std-ref">Customizing Collection Access</span></a>를 확인하라) 기본적으로는 파이썬 리스트다.</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Bean&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;gjffdd&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span><span class="o">.</span><span class="n">addresses</span>
<span class="p">[]</span>
</pre></div>
</div>
<p>우리는 자유롭게 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 객체를 <code class="docutils literal notranslate"><span class="pre">User</span></code> 객체에 추가할 수 있다. 이 경우 리스트 전체를 직접 할당할 것이다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span><span class="o">.</span><span class="n">addresses</span> <span class="o">=</span> <span class="p">[</span>
<span class="o">...</span>                 <span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">),</span>
<span class="o">...</span>                 <span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>bidirectional relationship을 사용할 때, 한 방향에서 추가된 요소는 자동적으로 다른 방향에서 보이게 된다. 이 동작은 변경시 속성에 기반해 발생하며 평가는 SQL을 사용하지 않고 파이썬으로 이루어진다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span><span class="o">.</span><span class="n">addresses</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span><span class="o">.</span><span class="n">addresses</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">user</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Bean&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;gjffdd&#39;</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Jack</span> <span class="pre">Bean</span></code>를 데이터베이스에 추가하고 커밋하자. <strong>cascading</strong>이라는 프로세스를 사용해서 <code class="docutils literal notranslate"><span class="pre">addresses</span></code>에 해당하는 두 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 멤버 뿐만 아니라 <code class="docutils literal notranslate"><span class="pre">jack</span></code>둘 다 세션에 한 번에 추가된다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">jack</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">INSERT INTO users (name, fullname, nickname) VALUES (?, ?, ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;jack&#39;, &#39;Jack Bean&#39;, &#39;gjffdd&#39;)</span>
<span class=" -Sql -Sql-Popup">INSERT INTO addresses (email_address, user_id) VALUES (?, ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;jack@google.com&#39;, 5)</span>
<span class=" -Sql -Sql-Popup">INSERT INTO addresses (email_address, user_id) VALUES (?, ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;j25@yahoo.com&#39;, 5)</span>
<span class=" -Sql -Sql-Popup">COMMIT</span>
</pre></div>
</div>
<p>Jack에 대해 쿼리하면 Jack을 돌려받는다. 아직 Jack의 addresses에 대한 SQL은 발행되지 않았다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">BEGIN (implicit)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;jack&#39;,)</span>

<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Bean&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;gjffdd&#39;</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">addresses</span></code> 컬렉션을 보자. SQL을 보아라:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span><span class="o">.</span><span class="n">addresses</span>
<span class=" -Sql -Sql-Popup">SELECT addresses.id AS addresses_id,</span>
<span class=" -Sql -Sql-Popup">        addresses.email_address AS</span>
<span class=" -Sql -Sql-Popup">        addresses_email_address,</span>
<span class=" -Sql -Sql-Popup">        addresses.user_id AS addresses_user_id</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE ? = addresses.user_id ORDER BY addresses.id</span>
<span class=" -Sql -Sql-Popup">(5,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[</span><span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">addresses</span></code> 컬렉션에 액세스 할 때, SQL이 갑자기 발행된다. 이것은 <a class="reference internal" href="../glossary.html#term-lazy-loading"><span class="xref std std-term">lazy loading</span></a> relationship의 한 예이다. <code class="docutils literal notranslate"><span class="pre">addresses</span></code> 컬렉션이 이제 로드됐고 일반적인 리스트처럼 동작한다. 잠시 뒤에 이 컬렉션 로딩을 최척화 하는 법을 다룰 것이다.</p>
</div>
<div class="section" id="querying-with-joins">
<span id="ormtutorial-joins"></span><h2>Join으로 쿼리쓰기(Querying with Joins)<a class="headerlink" href="#querying-with-joins" title="제목 주소">¶</a></h2>
<p>이제 두 테이블이 있기 때문에 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>의 더 많은 기능들을 볼 수 있다. 특히 동시에 두 테이블을 다루는 커리를 만드는 방법을 보게 될 것이다. <a class="reference external" href="http://en.wikipedia.org/wiki/Join_%28SQL%29">Wikipedia page on SQL JOIN</a>은  여기서 소게 할 몇몇 join 테크닉에 대한 좋은 소개를 제공해준다.</p>
<p><code class="docutils literal notranslate"><span class="pre">Join</span></code>과 <code class="docutils literal notranslate"><span class="pre">Address</span></code>사이에 간단한 암시적 join을 생성하기 위해서 우리는 관계된 컬럼을 동일시하는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.filter" title="sqlalchemy.orm.query.Query.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.filter()</span></code></a>를 사용할 것이다. 아래에서 우리는 <code class="docutils literal notranslate"><span class="pre">User</span></code>와 <code class="docutils literal notranslate"><span class="pre">Address</span></code>개체를 이 메서드를 사용해 한 번에 로드했다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                     <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                     <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                     <span class="nb">all</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname,</span>
<span class=" -Sql -Sql-Popup">        addresses.id AS addresses_id,</span>
<span class=" -Sql -Sql-Popup">        addresses.email_address AS addresses_email_address,</span>
<span class=" -Sql -Sql-Popup">        addresses.user_id AS addresses_user_id</span>
<span class=" -Sql -Sql-Popup">FROM users, addresses</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = addresses.user_id</span>
<span class=" -Sql -Sql-Popup">        AND addresses.email_address = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;jack@google.com&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Bean&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;gjffdd&#39;</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>반면에, 실제 SQL JOIN 신택스는, <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.join" title="sqlalchemy.orm.query.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> 메서드를 사용해 쉽게 만들 수 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>         <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>         <span class="nb">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users JOIN addresses ON users.id = addresses.user_id</span>
<span class=" -Sql -Sql-Popup">WHERE addresses.email_address = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;jack@google.com&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Bean&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;gjffdd&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.join" title="sqlalchemy.orm.query.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">User</span></code>과 <code class="docutils literal notranslate"><span class="pre">Address</span></code>를 join하는 방법을 알고 있다. 왜냐하면 둘 사이에는 단 하나의 foreign key가 존재하기 때문이다. foreign key가 없거나,여러개 있다면 아래의 형식을 사용했을 때, <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.join" title="sqlalchemy.orm.query.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a>가 더 잘 작동한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>    <span class="c1"># explicit condition</span>
<span class="n">query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span>                       <span class="c1"># specify relationship from left to right</span>
<span class="n">query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span>              <span class="c1"># same, with explicit target</span>
<span class="n">query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;addresses&#39;</span><span class="p">)</span>                          <span class="c1"># same, using a string</span>
</pre></div>
</div>
<p>예상했다시피 같은 아이디어가 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.outerjoin" title="sqlalchemy.orm.query.Query.outerjoin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">outerjoin()</span></code></a>함수를 통해 &quot;outer&quot; join에서도 사용된다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">outerjoin</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span>   <span class="c1"># LEFT OUTER JOIN</span>
</pre></div>
</div>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.join" title="sqlalchemy.orm.query.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a>에 대한 참고 문서는 상세한 정보와 이 메서드에 의해 용인되는 호출 스타일에 대한 예시를 담고 있다; <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.join" title="sqlalchemy.orm.query.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a>은 SQL-fluent 어플리케이션 사용의 중심에 있는 중요한 메서드다.</p>
<div class="topic">
<p class="topic-title first">만약 여러 개의 개체가 있을 경우 어떤 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>가 선택되어야 하는가?</p>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.join" title="sqlalchemy.orm.query.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> 메서드는 ON clause가 생략됐을 때나, ON cluase가 일반 SQL 표현식일 때, 개체 리스트에 있는 <strong>일반적으로 가장 촤측의 항목에서 join한다</strong> JOIN의 리스트에 있는 첫 번째 개체를 조작하고 싶으면 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.select_from" title="sqlalchemy.orm.query.Query.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.select_from()</span></code></a> 메서드를 사용하라:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="using-aliases">
<span id="ormtutorial-aliases"></span><h3>Alias 사용하기(Using Aliases)<a class="headerlink" href="#using-aliases" title="제목 주소">¶</a></h3>
<p>여러 테이블에 걸친 쿼리를 할 때, 같은 테이블이 한 번 이상 참조되어야 한다면, SQL은 일반적으로 해당 테이블을 다른 이름으로 <em>aliased</em>할 것을 요구하며 이를 통해서 그 테이블이 다른 곳에서 등장하는 것을 구분할 수 있다. <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>는 이것을 <a class="reference internal" href="query.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-attr docutils literal notranslate"><span class="pre">aliased</span></code></a> 구조를 사용해서 아주 명시적으로 지원한다. 아래에서 우리는 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 개체를 두 번 join 시켜서, 두 개의 다른 이메일 주소를 가진 사용자를 동시에 찾아냈다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">aliased</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">adalias1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">adalias2</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">username</span><span class="p">,</span> <span class="n">email1</span><span class="p">,</span> <span class="n">email2</span> <span class="ow">in</span> \
<span class="o">...</span>     <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">adalias1</span><span class="o">.</span><span class="n">email_address</span><span class="p">,</span> <span class="n">adalias2</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>     <span class="n">join</span><span class="p">(</span><span class="n">adalias1</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>     <span class="n">join</span><span class="p">(</span><span class="n">adalias2</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>     <span class="nb">filter</span><span class="p">(</span><span class="n">adalias1</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>     <span class="nb">filter</span><span class="p">(</span><span class="n">adalias2</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="n">email1</span><span class="p">,</span> <span class="n">email2</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        addresses_1.email_address AS addresses_1_email_address,</span>
<span class=" -Sql -Sql-Popup">        addresses_2.email_address AS addresses_2_email_address</span>
<span class=" -Sql -Sql-Popup">FROM users JOIN addresses AS addresses_1</span>
<span class=" -Sql -Sql-Popup">        ON users.id = addresses_1.user_id</span>
<span class=" -Sql -Sql-Popup">JOIN addresses AS addresses_2</span>
<span class=" -Sql -Sql-Popup">        ON users.id = addresses_2.user_id</span>
<span class=" -Sql -Sql-Popup">WHERE addresses_1.email_address = ?</span>
<span class=" -Sql -Sql-Popup">        AND addresses_2.email_address = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;jack@google.com&#39;, &#39;j25@yahoo.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="n">jack</span> <span class="n">jack</span><span class="nd">@google.com</span> <span class="n">j25</span><span class="nd">@yahoo.com</span>
</pre></div>
</div>
</div>
<div class="section" id="using-subqueries">
<h3>서브쿼리 사용하기(Using Subqueries)<a class="headerlink" href="#using-subqueries" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>는 서브 쿼리로 사용될 수 있는 명령을 생성하는 데도 적합하다. <code class="docutils literal notranslate"><span class="pre">User</span></code> 객체를 각 user가 몇 개의 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 기록을 가지고 있는지 카운트 한 결과와 같이 로드하고 싶다고 가정하자. SQL을 생성하기 가장 좋은 방법은 카운팅된 addresses를 user id로 group by해서 얻고 부모에 JOIN 시키는 것이다. 이 경우 우리는 LEFT OUTER JOIN을 사용했고 addresses가 없는 user 행을 돌려 받았다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">users</span><span class="o">.*</span><span class="p">,</span> <span class="n">adr_count</span><span class="o">.</span><span class="n">address_count</span> <span class="n">FROM</span> <span class="n">users</span> <span class="n">LEFT</span> <span class="n">OUTER</span> <span class="n">JOIN</span>
    <span class="p">(</span><span class="n">SELECT</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">AS</span> <span class="n">address_count</span>
        <span class="n">FROM</span> <span class="n">addresses</span> <span class="n">GROUP</span> <span class="n">BY</span> <span class="n">user_id</span><span class="p">)</span> <span class="n">AS</span> <span class="n">adr_count</span>
    <span class="n">ON</span> <span class="n">users</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">adr_count</span><span class="o">.</span><span class="n">user_id</span>
</pre></div>
</div>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>를 사용해서, 이러한 명령을 내부에서 밖으로 생성할 수 있다. <code class="docutils literal notranslate"><span class="pre">statement</span></code> 접근자는 특정한 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>에 의해 생성된 명령을 나타내는 SQL 표현식을 반환한다. - 이것은 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 구조의 인스턴스이며 <a class="reference internal" href="../core/tutorial.html#sqlexpression-toplevel"><span class="std std-ref">SQL Expression Language Tutorial</span></a>에 설명되어 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="k">import</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">label</span><span class="p">(</span><span class="s1">&#39;address_count&#39;</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">group_by</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">func</span></code> 키워드는 SQL 함수를 생성하고 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">subquery()</span></code> 메서드는 alias로 임베디드된 SELECT 명령을 나타내는 SQL 표현식 구조를 생성한다 (이것은 사실 <code class="docutils literal notranslate"><span class="pre">query.statement.alias()</span></code>의 축약형이다).</p>
<p>명령문을 만들면, 이 명령문은 <code class="docutils literal notranslate"><span class="pre">users</span></code> 때문에 튜토리얼 첫 부분에서 만들었던 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 구조처럼 동작한다. 명령문의 컬럼은 <code class="docutils literal notranslate"><span class="pre">c</span></code>라고 하는 속성을 통해 접근할 수 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">address_count</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>     <span class="n">outerjoin</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="n">stmt</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname,</span>
<span class=" -Sql -Sql-Popup">        anon_1.address_count AS anon_1_address_count</span>
<span class=" -Sql -Sql-Popup">FROM users LEFT OUTER JOIN</span>
<span class=" -Sql -Sql-Popup">    (SELECT addresses.user_id AS user_id, count(?) AS address_count</span>
<span class=" -Sql -Sql-Popup">    FROM addresses GROUP BY addresses.user_id) AS anon_1</span>
<span class=" -Sql -Sql-Popup">    ON users.id = anon_1.user_id</span>
<span class=" -Sql -Sql-Popup">ORDER BY users.id</span>
<span class=" -Sql -Sql-Popup">(&#39;*&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;eddie&#39;</span><span class="p">)</span><span class="o">&gt;</span> <span class="bp">None</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;windy&#39;</span><span class="p">)</span><span class="o">&gt;</span> <span class="bp">None</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Mary Contrary&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;mary&#39;</span><span class="p">)</span><span class="o">&gt;</span> <span class="bp">None</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fred&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Fred Flintstone&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;freddy&#39;</span><span class="p">)</span><span class="o">&gt;</span> <span class="bp">None</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Bean&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;gjffdd&#39;</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="selecting-entities-from-subqueries">
<h3>서브 쿼리에서 개체 선택하기(Selecting Entities from Subqueries)<a class="headerlink" href="#selecting-entities-from-subqueries" title="제목 주소">¶</a></h3>
<p>위에서 우리는 서브쿼리의 컬럼을 포함하는 결과를 select했다. 만약 서브 쿼리를 개체에 매핑하려면 어떻게 해야 할까? 이 경우 매핑된 클래스의 &quot;alias&quot;를 서브 쿼리에 <code class="docutils literal notranslate"><span class="pre">alisased()</span></code>를 사용해서 결합하면 된다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                 <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span> <span class="o">!=</span> <span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                 <span class="n">subquery</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">adalias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">,</span> <span class="n">stmt</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">user</span><span class="p">,</span> <span class="n">address</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">adalias</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>         <span class="n">join</span><span class="p">(</span><span class="n">adalias</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">            users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">            users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">            users.nickname AS users_nickname,</span>
<span class=" -Sql -Sql-Popup">            anon_1.id AS anon_1_id,</span>
<span class=" -Sql -Sql-Popup">            anon_1.email_address AS anon_1_email_address,</span>
<span class=" -Sql -Sql-Popup">            anon_1.user_id AS anon_1_user_id</span>
<span class=" -Sql -Sql-Popup">FROM users JOIN</span>
<span class=" -Sql -Sql-Popup">    (SELECT addresses.id AS id,</span>
<span class=" -Sql -Sql-Popup">            addresses.email_address AS email_address,</span>
<span class=" -Sql -Sql-Popup">            addresses.user_id AS user_id</span>
<span class=" -Sql -Sql-Popup">    FROM addresses</span>
<span class=" -Sql -Sql-Popup">    WHERE addresses.email_address != ?) AS anon_1</span>
<span class=" -Sql -Sql-Popup">    ON users.id = anon_1.user_id</span>
<span class=" -Sql -Sql-Popup">(&#39;j25@yahoo.com&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Bean&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;gjffdd&#39;</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="using-exists">
<h3>EXISTS 사용하기(Using EXIST)<a class="headerlink" href="#using-exists" title="제목 주소">¶</a></h3>
<p>SQL의 EXISTS 키워드는 불리언 연산자로 주어진 표현식이 행을 포함하고 있으면 참을 반환한다. 이것은 join을 대체해서 많은 시나리오에서 사용될 수 있으며 연결된 테이블에 대응하는 행이 없는 행을 찾을 때에도 유용하다.</p>
<p>There is an explicit EXISTS construct, which looks like this:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">exists</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">exists</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="o">==</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.name AS users_name</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE EXISTS (SELECT *</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE addresses.user_id = users.id)</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="n">jack</span>
</pre></div>
</div>
<p><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>는 EXISTS를 자동적으로 사용하는 몇몇 오퍼레이터가 있다. 위에서, 명령문은 <a class="reference internal" href="internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.any" title="sqlalchemy.orm.properties.RelationshipProperty.Comparator.any"><code class="xref py py-meth docutils literal notranslate"><span class="pre">any()</span></code></a>을 사용해서 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> relationship로 표현될 수 있다.</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>         <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.name AS users_name</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE EXISTS (SELECT 1</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = addresses.user_id)</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="n">jack</span>
</pre></div>
</div>
<p><a class="reference internal" href="internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.any" title="sqlalchemy.orm.properties.RelationshipProperty.Comparator.any"><code class="xref py py-meth docutils literal notranslate"><span class="pre">any()</span></code></a>는 매칭되는 행 갯수를 제한하기 위해 조건을 취하기도 한다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>     <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%g</span><span class="s1">oogle%&#39;</span><span class="p">))):</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.name AS users_name</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE EXISTS (SELECT 1</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = addresses.user_id AND addresses.email_address LIKE ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;%google%&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="n">jack</span>
</pre></div>
</div>
<p><a class="reference internal" href="internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.has" title="sqlalchemy.orm.properties.RelationshipProperty.Comparator.has"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has()</span></code></a>는다대일 relationship을 위한 <a class="reference internal" href="internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.any" title="sqlalchemy.orm.properties.RelationshipProperty.Comparator.any"><code class="xref py py-meth docutils literal notranslate"><span class="pre">any()</span></code></a>와 동일하다. (여기에도 <code class="docutils literal notranslate"><span class="pre">~</span></code> 연산자가 있다, 이것은 &quot;NOT&quot;을 의미한다):</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>         <span class="nb">filter</span><span class="p">(</span><span class="o">~</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s1">&#39;jack&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT addresses.id AS addresses_id,</span>
<span class=" -Sql -Sql-Popup">        addresses.email_address AS addresses_email_address,</span>
<span class=" -Sql -Sql-Popup">        addresses.user_id AS addresses_user_id</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE NOT (EXISTS (SELECT 1</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = addresses.user_id AND users.name = ?))</span>
<span class=" -Sql -Sql-Popup">(&#39;jack&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[]</span>
</pre></div>
</div>
</div>
<div class="section" id="common-relationship-operators">
<h3>일반 Relationship 연산자(Common Relationship Operator)<a class="headerlink" href="#common-relationship-operators" title="제목 주소">¶</a></h3>
<p>아래에는 relationship을 기반으로하는 모든 연산자가 있다 -각각은 사용법과 동작에 대한 전체 내용이 있는 API 문서에 연결되어 있다:</p>
<ul>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code> (다대일 동일 대조):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span> <span class="o">==</span> <span class="n">someuser</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code> (다대일 비동일 대조):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span> <span class="o">!=</span> <span class="n">someuser</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">IS NULL (다대일 대조, 다음 방식을 사용할 수도 있음 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.contains" title="sqlalchemy.orm.properties.RelationshipProperty.Comparator.contains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contains()</span></code></a> (일대다 컬렉션에 사용됨):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">someaddress</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.any" title="sqlalchemy.orm.properties.RelationshipProperty.Comparator.any"><code class="xref py py-meth docutils literal notranslate"><span class="pre">any()</span></code></a> (컬렉션에 사용됨):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;bar&#39;</span><span class="p">))</span>

<span class="c1"># also takes keyword arguments:</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.has" title="sqlalchemy.orm.properties.RelationshipProperty.Comparator.has"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has()</span></code></a> (스칼라 참조에 사용됨):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.with_parent" title="sqlalchemy.orm.query.Query.with_parent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.with_parent()</span></code></a> (모든 relationship에 사용됨):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">with_parent</span><span class="p">(</span><span class="n">someuser</span><span class="p">,</span> <span class="s1">&#39;addresses&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="eager-loading">
<h2>Eager 로딩(Eager Loading)<a class="headerlink" href="#eager-loading" title="제목 주소">¶</a></h2>
<p>이전에 <code class="docutils literal notranslate"><span class="pre">User</span></code>의 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code>컬렉션에 접근하고 SQL이 내보내졌을 때 <a class="reference internal" href="../glossary.html#term-lazy-loading"><span class="xref std std-term">lazy loading</span></a> 작동에 대해서 설명한 것을 기억해보자. 만약 (대부분의 경우에, 극적으로) 쿼리의 수를 줄이고 싶다면 쿼리 작동에 <span class="xref std std-term">eager load</span>를 적용시킬 수 있다. SQLAlchemy는 세 가지 타입의 eager loading을 제공하며, 이중 두 가지는 자동이고,하나는 커스텀 조건을 포함하고 있다. 세 가지 모두 <span class="xref std std-term">query options</span>이라 하는 함수를 통해서 호출되고 이 함수는 추가적인 지시사항(다양한 속성을 어떻게 로드할 것인가)을 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.options" title="sqlalchemy.orm.query.Query.options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.options()</span></code></a> 메서드를 통해 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>에 제공한다.</p>
<div class="section" id="selectin-load">
<h3>Selectin 로드(Selectin Load)<a class="headerlink" href="#selectin-load" title="제목 주소">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">User.addresses</span></code>가 단번에 로드되게 지시하고 싶은 경우. 객체 집합과 연결된 컬렉션을 같이 로드하기 위한 좋은 선택지는 <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.subqueryload" title="sqlalchemy.orm.subqueryload"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.subqueryload()</span></code></a> 옵션이다. 이 옵션은 로드된 결과와 연관된 컬렉션을 완전히 로드하는 두 번째 SELECT 명령문을 내보낸다. &quot;selectin&quot;라는 이름은 SELECET 명령문이 여러 객체에 대한 관련된 행을 한 번에 찾기 위해서 IN 절을 사용한다는 점 때문에 만들어졌다.</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">selectinload</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                 <span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span>                 <span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;jack&#39;,)</span>
<span class=" -Sql -Sql-Popup">SELECT addresses.user_id AS addresses_user_id,</span>
<span class=" -Sql -Sql-Popup">        addresses.id AS addresses_id,</span>
<span class=" -Sql -Sql-Popup">        addresses.email_address AS addresses_email_address</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE addresses.user_id IN (?)</span>
<span class=" -Sql -Sql-Popup">ORDER BY addresses.user_id, addresses.id</span>
<span class=" -Sql -Sql-Popup">(5,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Bean&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;gjffdd&#39;</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span><span class="o">.</span><span class="n">addresses</span>
<span class="p">[</span><span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="joined-load">
<h3>Joined 로드(Joined Load)<a class="headerlink" href="#joined-load" title="제목 주소">¶</a></h3>
<p>다른 자동 eager loading 함수는 더 잘 알려져있으며 <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.joinedload()</span></code></a>라고 한다. 이 로딩 스타일은 JOIN(기본적으로 LEFT OUTER JOIN)을 내보내고, 관련된 객체나 컬렉션 뿐만 아니라 리드 객체까지 한 번에 로드한다. 우리는 이 방식으로 같은 <code class="docutils literal notranslate"><span class="pre">addresses</span></code> 컬렉션을 로드하는 것을 설명할 수 있다. - <code class="docutils literal notranslate"><span class="pre">jack</span></code>에 있는 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> 컬렉션이 지금 populated 되었더라도, 쿼리는 상관 없이 추가 join을 내보낼 것이다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">joinedload</span>

<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                        <span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span>                        <span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname,</span>
<span class=" -Sql -Sql-Popup">        addresses_1.id AS addresses_1_id,</span>
<span class=" -Sql -Sql-Popup">        addresses_1.email_address AS addresses_1_email_address,</span>
<span class=" -Sql -Sql-Popup">        addresses_1.user_id AS addresses_1_user_id</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">    LEFT OUTER JOIN addresses AS addresses_1 ON users.id = addresses_1.user_id</span>
<span class=" -Sql -Sql-Popup">WHERE users.name = ? ORDER BY addresses_1.id</span>
<span class=" -Sql -Sql-Popup">(&#39;jack&#39;,)</span>

<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Bean&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;gjffdd&#39;</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span><span class="o">.</span><span class="n">addresses</span>
<span class="p">[</span><span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<p>OUTER JOIN이 두 행을 결과로 가지더라도, 우리는 여전히 하나의 <code class="docutils literal notranslate"><span class="pre">User</span></code> 인스턴스만 돌려받는다. 왜냐하면 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>가 객체 아이덴티티에 기반을 둔 &quot;uniquing&quot; 전략을 반환된 개체에 적용하고 있기 때문이다. 이것은 특히 join된 eager loading이 쿼리 결과에 영향을 미치지않고 적용될 수 있게 한다.</p>
<p><a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a>이 오랫동안 존재해왔던 반면에 <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.subqueryload" title="sqlalchemy.orm.subqueryload"><code class="xref py py-func docutils literal notranslate"><span class="pre">subqueryload()</span></code></a>새로 등장한 eager loading 형태다. <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a>는 리드 객체와 연관된 객체에 대해 하나의 행만 로드된다는 사실 때문에 다대일 relationship에 더 적합한 반면 <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.subqueryload" title="sqlalchemy.orm.subqueryload"><code class="xref py py-func docutils literal notranslate"><span class="pre">subqueryload()</span></code></a>는 연관된 컬렉션을 로드하는 데 더 적합한 경향이 있다.</p>
<div class="topic">
<p class="topic-title first"><code class="docutils literal notranslate"><span class="pre">joinedload()</span></code>는 <code class="docutils literal notranslate"><span class="pre">join()</span></code>를 대체하는 것이 아니다.</p>
<p><a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a>로 생성된 join은 익명으로 aliased 되어서 <strong>쿼리 결과에 영향을 미치지 않는다</strong>. <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.order_by" title="sqlalchemy.orm.query.Query.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.order_by()</span></code></a> 또는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.filter" title="sqlalchemy.orm.query.Query.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.filter()</span></code></a> 호출은 이 aliased 테이블을 참조하지 <strong>못한다</strong> - 소위 &quot;user space&quot; join은 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.join" title="sqlalchemy.orm.query.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a>을 사용해서 생성된다. <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a>는 오로지 연관된 객체나 컬렉션이 optimizing detail로서 로드되는 방식에 영향을 주기위해만 적용된다. 실제 결과에 영향을 주지 않고 제거되거나 추가될 수 있다. 사용되는 방식에 대한 자세한 설명은 <a class="reference internal" href="loading_relationships.html#zen-of-eager-loading"><span class="std std-ref">The Zen of Joined Eager Loading</span></a>를 참고하라.</p>
</div>
</div>
<div class="section" id="explicit-join-eagerload">
<h3>명시적 Join + Eagerload(Explicit Join + Eagerload)<a class="headerlink" href="#explicit-join-eagerload" title="제목 주소">¶</a></h3>
<p>세 번째 스타일의 eager loading은 primary 행을 찾기 위해 명시적으로 JOIN을 생성할 때와 추가 테이블을 관련된 객체나 primary 객체의 컬렉션에 적용하고 싶을 때 사용한다. 이 기능은 <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.contains_eager" title="sqlalchemy.orm.contains_eager"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.contains_eager()</span></code></a> 함수를 사용해서 제공되며, 일반적으로 동일한 객체에 대한 필터링이 필요한 쿼리의 다대일 객체를 프리로딩 할 때 가장 유용하다. 아래에서 우리는 &quot;jack&quot; 이름의 <code class="docutils literal notranslate"><span class="pre">User</span></code>를 필터링하고 <a class="reference internal" href="loading_relationships.html#sqlalchemy.orm.contains_eager" title="sqlalchemy.orm.contains_eager"><code class="xref py py-func docutils literal notranslate"><span class="pre">orm.contains_eager()</span></code></a>를 사용해서 &quot;user&quot; 컬럼을 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 속성에 적용하면서 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 행과, 관련된 <code class="docutils literal notranslate"><span class="pre">User</span></code> 객체까지 로드하는 것을 설명했다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">contains_eager</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">jacks_addresses</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                             <span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                             <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                             <span class="n">options</span><span class="p">(</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span>                             <span class="nb">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname,</span>
<span class=" -Sql -Sql-Popup">        addresses.id AS addresses_id,</span>
<span class=" -Sql -Sql-Popup">        addresses.email_address AS addresses_email_address,</span>
<span class=" -Sql -Sql-Popup">        addresses.user_id AS addresses_user_id</span>
<span class=" -Sql -Sql-Popup">FROM addresses JOIN users ON users.id = addresses.user_id</span>
<span class=" -Sql -Sql-Popup">WHERE users.name = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;jack&#39;,)</span>

<span class=" -Sql -Sql-Popup">{stop}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">jacks_addresses</span>
<span class="p">[</span><span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">jacks_addresses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">user</span>
<span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Bean&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;gjffdd&#39;</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>다양한 형태의 기본 로딩 설정을 조정하는 방법과 eager loading에 대한 자세한 정보는 <a class="reference internal" href="loading_relationships.html"><span class="doc">Relationship Loading Techniques</span></a>를 참고하라.</p>
</div>
</div>
<div class="section" id="deleting">
<h2>삭제하기(Deleting)<a class="headerlink" href="#deleting" title="제목 주소">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">jack</span></code>을 지우고 어떻게 진행되는지를 보자. 세션에서 객체를 삭제한 것으로 표시하고 남아있는 행이 없는지 확인하기 위해 <code class="docutils literal notranslate"><span class="pre">count</span></code> 쿼리를 발행할 것이다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">jack</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">UPDATE addresses SET user_id=? WHERE addresses.id = ?</span>
<span class=" -Sql -Sql-Popup">((None, 1), (None, 2))</span>
<span class=" -Sql -Sql-Popup">DELETE FROM users WHERE users.id = ?</span>
<span class=" -Sql -Sql-Popup">(5,)</span>
<span class=" -Sql -Sql-Popup">SELECT count(*) AS count_1</span>
<span class=" -Sql -Sql-Popup">FROM (SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name = ?) AS anon_1</span>
<span class=" -Sql -Sql-Popup">(&#39;jack&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="mi">0</span>
</pre></div>
</div>
<p>현재까지는 이상이 없다. Jack의 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 객체는 어떨까?</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="o">...</span>     <span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">,</span> <span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">])</span>
<span class="o">...</span>  <span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT count(*) AS count_1</span>
<span class=" -Sql -Sql-Popup">FROM (SELECT addresses.id AS addresses_id,</span>
<span class=" -Sql -Sql-Popup">                addresses.email_address AS addresses_email_address,</span>
<span class=" -Sql -Sql-Popup">                addresses.user_id AS addresses_user_id</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE addresses.email_address IN (?, ?)) AS anon_1</span>
<span class=" -Sql -Sql-Popup">(&#39;jack@google.com&#39;, &#39;j25@yahoo.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="mi">2</span>
</pre></div>
</div>
<p>아직까지 남아있다! flush SQL을 분석해보면, 각 address의 <code class="docutils literal notranslate"><span class="pre">user_id</span></code> 컬럼이 NULL로 설정되있지만 행이 삭제되지는 않은 것을 볼 수 있다. SQLAlchemy는 cascade를 삭제를 함부로 가정하지 않는다. 당신이 직접 그렇게 하도록 명령해야 한다.</p>
<div class="section" id="configuring-delete-delete-orphan-cascade">
<span id="tutorial-delete-cascade"></span><h3>delete/delete-orphan Cascade 설정하기(Configuring delete/delete-orphan Cascade)<a class="headerlink" href="#configuring-delete-delete-orphan-cascade" title="제목 주소">¶</a></h3>
<p>동작을 변경하기 위해 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> relationship에 있는 <strong>cascade</strong> 옵션을 설정할 것이다. SQLAlchemy는 새로운 속성과 relationship을 어느 시점에나 매핑에 추가할 수 있게 해주지만 이 경우에는 이미 존재하는 relationship을 제거해야 하므로 매핑을 완전히 제거하고 새로 시작해야 할 필요가 있다 - 우리는 <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>을 닫을 것이다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">ROLLBACK</span>
</pre></div>
</div>
<p>and use a new <a class="reference internal" href="extensions/declarative/api.html#sqlalchemy.ext.declarative.declarative_base" title="sqlalchemy.ext.declarative.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>
</pre></div>
</div>
<p>그 다음 <code class="docutils literal notranslate"><span class="pre">User</span></code> 클래스를 선언하고, cascade 설정을 포함한 <code class="docutils literal notranslate"><span class="pre">addresses</span></code> relationship을 추가할 것이다 (컨스트럭터는 생략할 것이다):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;users&#39;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">fullname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">nickname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">addresses</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s1">&#39;user&#39;</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">cascade</span><span class="o">=</span><span class="s2">&quot;all, delete, delete-orphan&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>       <span class="k">return</span> <span class="s2">&quot;&lt;User(name=&#39;</span><span class="si">%s</span><span class="s2">&#39;, fullname=&#39;</span><span class="si">%s</span><span class="s2">&#39;, nickname=&#39;</span><span class="si">%s</span><span class="s2">&#39;)&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
<span class="gp">... </span>                               <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nickname</span><span class="p">)</span>
</pre></div>
</div>
<p>그리고 <code class="docutils literal notranslate"><span class="pre">Address</span></code>를 다시 생성한다, 이 경우 이미 <code class="docutils literal notranslate"><span class="pre">User</span></code> 클래스를 통해서 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> relationship을 생성했다는 것을 명심하라:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;addresses&#39;</span>
<span class="gp">... </span>    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">email_address</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">user_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;users.id&#39;</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">user</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;User&quot;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s2">&quot;&lt;Address(email_address=&#39;</span><span class="si">%s</span><span class="s2">&#39;)&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">email_address</span>
</pre></div>
</div>
<p>이제 user <code class="docutils literal notranslate"><span class="pre">jack</span></code>을 로드할 때 (primary key로 로드하는 <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.get" title="sqlalchemy.orm.query.Query.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>를 사용했다), <code class="docutils literal notranslate"><span class="pre">addresses</span></code> 컬렉션에 대응하는 address를 제거하면 <code class="docutils literal notranslate"><span class="pre">Address</span></code>도 제거되는 결과를 얻을 수 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="c1"># load Jack by primary key</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">BEGIN (implicit)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = ?</span>
<span class=" -Sql -Sql-Popup">(5,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span>

<span class="c1"># remove one Address (lazy load fires off)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">jack</span><span class="o">.</span><span class="n">addresses</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class=" -Sql -Sql-Popup">SELECT addresses.id AS addresses_id,</span>
<span class=" -Sql -Sql-Popup">        addresses.email_address AS addresses_email_address,</span>
<span class=" -Sql -Sql-Popup">        addresses.user_id AS addresses_user_id</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE ? = addresses.user_id</span>
<span class=" -Sql -Sql-Popup">(5,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span>

<span class="c1"># only one address remains</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="o">...</span>     <span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">,</span> <span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">])</span>
<span class="o">...</span> <span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">DELETE FROM addresses WHERE addresses.id = ?</span>
<span class=" -Sql -Sql-Popup">(2,)</span>
<span class=" -Sql -Sql-Popup">SELECT count(*) AS count_1</span>
<span class=" -Sql -Sql-Popup">FROM (SELECT addresses.id AS addresses_id,</span>
<span class=" -Sql -Sql-Popup">                addresses.email_address AS addresses_email_address,</span>
<span class=" -Sql -Sql-Popup">                addresses.user_id AS addresses_user_id</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE addresses.email_address IN (?, ?)) AS anon_1</span>
<span class=" -Sql -Sql-Popup">(&#39;jack@google.com&#39;, &#39;j25@yahoo.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="mi">1</span>
</pre></div>
</div>
<p>Jack을 삭제하면 Jack과 그 user와 연결된 <code class="docutils literal notranslate"><span class="pre">Address</span></code>도 제거된다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">jack</span><span class="p">)</span>

<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">DELETE FROM addresses WHERE addresses.id = ?</span>
<span class=" -Sql -Sql-Popup">(1,)</span>
<span class=" -Sql -Sql-Popup">DELETE FROM users WHERE users.id = ?</span>
<span class=" -Sql -Sql-Popup">(5,)</span>
<span class=" -Sql -Sql-Popup">SELECT count(*) AS count_1</span>
<span class=" -Sql -Sql-Popup">FROM (SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">                users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">                users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">                users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name = ?) AS anon_1</span>
<span class=" -Sql -Sql-Popup">(&#39;jack&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="mi">0</span>

<span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="o">...</span>    <span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">,</span> <span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">])</span>
<span class="o">...</span> <span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT count(*) AS count_1</span>
<span class=" -Sql -Sql-Popup">FROM (SELECT addresses.id AS addresses_id,</span>
<span class=" -Sql -Sql-Popup">                addresses.email_address AS addresses_email_address,</span>
<span class=" -Sql -Sql-Popup">                addresses.user_id AS addresses_user_id</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE addresses.email_address IN (?, ?)) AS anon_1</span>
<span class=" -Sql -Sql-Popup">(&#39;jack@google.com&#39;, &#39;j25@yahoo.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="mi">0</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Cascade에 대한 추가 내용</p>
<p>cascade 설정에 대한 세부 사항은 <a class="reference internal" href="cascades.html#unitofwork-cascades"><span class="std std-ref">Cascades</span></a>에 설명되어 있다. cascade 기능은 관계형 데이터베이스의 <code class="docutils literal notranslate"><span class="pre">ON</span> <span class="pre">DELETE</span> <span class="pre">CASCADE</span></code> 기능과 원활하게 통합될 수도 있다. 자세한 내용은 <a class="reference internal" href="collections.html#passive-deletes"><span class="std std-ref">Using Passive Deletes</span></a>를 참고하라</p>
</div>
</div>
</div>
<div class="section" id="building-a-many-to-many-relationship">
<span id="orm-tutorial-many-to-many"></span><h2>Building a Many To Many Relationship<a class="headerlink" href="#building-a-many-to-many-relationship" title="제목 주소">¶</a></h2>
<p>여기서 보너스 라운드로 이동하기 전에 다대다 관계를 보여줄 것이다. 물론 다른 기능들도 둘러볼 것이다. 우리는 사용자가 <code class="docutils literal notranslate"><span class="pre">BlogPost</span></code>와 연관된 <code class="docutils literal notranslate"><span class="pre">Keyword</span></code> 항목이 있는 <code class="docutils literal notranslate"><span class="pre">BlogPost</span></code>을 작성하는 블로그 어플리케이션을 만들 것이다.</p>
<p>일반적인 다대다의 경우, 매핑되지 않은 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 구조를 생성해서 연결 테이블로 활용해야 한다. 방식은 아래와 같다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># association table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">post_keywords</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;post_keywords&#39;</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;post_id&#39;</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;posts.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;keyword_id&#39;</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;keywords.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>위에서 우리는 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>를 직접 선언하는 것이 매핑된 클래스를 생성하는 것과 조금 다르다는 사실을 볼 수 있다. <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>는 constructor 함수로, 개별 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 인수는 콤마로 나뉘어져 있다. <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 객체는 할당된 속성 이름에서 가져오는 것이 아니라 명시적으로 이름을 제공받는다.</p>
<p>그 다음 우리는 상호보완적인 <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 구조를 사용해 <code class="docutils literal notranslate"><span class="pre">BlogPost</span></code>와 <code class="docutils literal notranslate"><span class="pre">Keyword</span></code>를 정의했고 각각은 <code class="docutils literal notranslate"><span class="pre">post_keywords</span></code>를 연결 테이블로 참조한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">BlogPost</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;posts&#39;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">user_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;users.id&#39;</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">headline</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">body</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Text</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="c1"># many to many BlogPost&lt;-&gt;Keyword</span>
<span class="gp">... </span>    <span class="n">keywords</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s1">&#39;Keyword&#39;</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">secondary</span><span class="o">=</span><span class="n">post_keywords</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">back_populates</span><span class="o">=</span><span class="s1">&#39;posts&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">headline</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">author</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">author</span> <span class="o">=</span> <span class="n">author</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">headline</span> <span class="o">=</span> <span class="n">headline</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s2">&quot;BlogPost(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">headline</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">author</span><span class="p">)</span>


<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Keyword</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;keywords&#39;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">keyword</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">posts</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s1">&#39;BlogPost&#39;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">secondary</span><span class="o">=</span><span class="n">post_keywords</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">back_populates</span><span class="o">=</span><span class="s1">&#39;keywords&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">위의 클래스 선언에서는 명시적인 <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 메서드를 보여주고 있다. Declarative를 사용할 때 이것은 선택적인 부분임을 명심하라!</p>
</div>
<p>위에서, 다대다 relationship은 <code class="docutils literal notranslate"><span class="pre">BlogPost.keywords</span></code>다. 다대다 relationship의 기능을 정의하는 것은 <code class="docutils literal notranslate"><span class="pre">secondary</span></code> 키워드 인수이며 이 인수는 연결 테이블을 나타내는 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 객체를 참조한다. 이 테이블은 relationship의 양쪽을 참조하는 컬럼만 포함한다; 만약 자신의 primary key나 다른 테이블에 대한 foreign key 같은 다른 컬럼을 포함하고 있다면 SQLAlchemy는 &quot;association object&quot;라고 하는 다른 사용 패턴을 요구한다. 이에 관해서는 <a class="reference internal" href="basic_relationships.html#association-pattern"><span class="std std-ref">Association Object</span></a>에서 설명하고 있다.</p>
<p>또한 우리는 <code class="docutils literal notranslate"><span class="pre">BlogPost</span></code> 클래스가 <code class="docutils literal notranslate"><span class="pre">author</span></code> 필드를 갖기를 원한다. 우리는 한 사용자가 많은 블로그 포스트를 작성할 수 있다는 것만 제외하면 이것을 다른 양방향 relationship으로 추가할 것이다.우리가 <code class="docutils literal notranslate"><span class="pre">User.posts</span></code>에 접근할 때, 전체 컬렉션을 다 로드하지 않도록 결과를 더 필터링할 수 있으면 좋을 것이다. 이것을 위해서 우리는 <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>의해 용인되는 <code class="docutils literal notranslate"><span class="pre">lazy='dynamic'</span></code>라고 불리는 세팅을 사용할 것이다. 이 세팅은 속성의 대체 <strong>loader strategy</strong>를구성한다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">BlogPost</span><span class="o">.</span><span class="n">author</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;posts&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">User</span><span class="o">.</span><span class="n">posts</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">BlogPost</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;author&quot;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s2">&quot;dynamic&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>새로운 테이블을 생성한다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">PRAGMA...</span>
<span class=" -Sql -Sql-Popup">CREATE TABLE keywords (</span>
<span class=" -Sql -Sql-Popup">    id INTEGER NOT NULL,</span>
<span class=" -Sql -Sql-Popup">    keyword VARCHAR(50) NOT NULL,</span>
<span class=" -Sql -Sql-Popup">    PRIMARY KEY (id),</span>
<span class=" -Sql -Sql-Popup">    UNIQUE (keyword)</span>
<span class=" -Sql -Sql-Popup">)</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">COMMIT</span>
<span class=" -Sql -Sql-Popup">CREATE TABLE posts (</span>
<span class=" -Sql -Sql-Popup">    id INTEGER NOT NULL,</span>
<span class=" -Sql -Sql-Popup">    user_id INTEGER,</span>
<span class=" -Sql -Sql-Popup">    headline VARCHAR(255) NOT NULL,</span>
<span class=" -Sql -Sql-Popup">    body TEXT,</span>
<span class=" -Sql -Sql-Popup">    PRIMARY KEY (id),</span>
<span class=" -Sql -Sql-Popup">    FOREIGN KEY(user_id) REFERENCES users (id)</span>
<span class=" -Sql -Sql-Popup">)</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">COMMIT</span>
<span class=" -Sql -Sql-Popup">CREATE TABLE post_keywords (</span>
<span class=" -Sql -Sql-Popup">    post_id INTEGER NOT NULL,</span>
<span class=" -Sql -Sql-Popup">    keyword_id INTEGER NOT NULL,</span>
<span class=" -Sql -Sql-Popup">    PRIMARY KEY (post_id, keyword_id),</span>
<span class=" -Sql -Sql-Popup">    FOREIGN KEY(post_id) REFERENCES posts (id),</span>
<span class=" -Sql -Sql-Popup">    FOREIGN KEY(keyword_id) REFERENCES keywords (id)</span>
<span class=" -Sql -Sql-Popup">)</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">COMMIT</span>
</pre></div>
</div>
<p>사용법은 해왔던 것에 비해서 크게 다르지 않다. Wendy에 블로그 포스트 몇 개를 추가하자:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">wendy</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                 <span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>                 <span class="n">one</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id AS users_id,</span>
<span class=" -Sql -Sql-Popup">        users.name AS users_name,</span>
<span class=" -Sql -Sql-Popup">        users.fullname AS users_fullname,</span>
<span class=" -Sql -Sql-Popup">        users.nickname AS users_nickname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;wendy&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">post</span> <span class="o">=</span> <span class="n">BlogPost</span><span class="p">(</span><span class="s2">&quot;Wendy&#39;s Blog Post&quot;</span><span class="p">,</span> <span class="s2">&quot;This is a test&quot;</span><span class="p">,</span> <span class="n">wendy</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
</pre></div>
</div>
<p>우리는 데이터베이스에서 키워드를 유니크하게 저장할 것이다, 하지만 저장된 키워드가 아직 없기 때문에 몇 개를 생성했다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">post</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Keyword</span><span class="p">(</span><span class="s1">&#39;wendy&#39;</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">post</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Keyword</span><span class="p">(</span><span class="s1">&#39;firstpost&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>이제 <cite>firstpost</cite> 키워드를 가진 모든 블로그 포스트를 찾을 수 있다. 우리는 <code class="docutils literal notranslate"><span class="pre">any</span></code> 오퍼레이터를 사용해서 키워드 문자열로 'fisrtpost'를 포함한 블로그 포스트를 찾을 수 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">BlogPost</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>             <span class="nb">filter</span><span class="p">(</span><span class="n">BlogPost</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">keyword</span><span class="o">=</span><span class="s1">&#39;firstpost&#39;</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span>             <span class="nb">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">INSERT INTO keywords (keyword) VALUES (?)</span>
<span class=" -Sql -Sql-Popup">(&#39;wendy&#39;,)</span>
<span class=" -Sql -Sql-Popup">INSERT INTO keywords (keyword) VALUES (?)</span>
<span class=" -Sql -Sql-Popup">(&#39;firstpost&#39;,)</span>
<span class=" -Sql -Sql-Popup">INSERT INTO posts (user_id, headline, body) VALUES (?, ?, ?)</span>
<span class=" -Sql -Sql-Popup">(2, &quot;Wendy&#39;s Blog Post&quot;, &#39;This is a test&#39;)</span>
<span class=" -Sql -Sql-Popup">INSERT INTO post_keywords (post_id, keyword_id) VALUES (?, ?)</span>
<span class=" -Sql -Sql-Popup">(...)</span>
<span class=" -Sql -Sql-Popup">SELECT posts.id AS posts_id,</span>
<span class=" -Sql -Sql-Popup">        posts.user_id AS posts_user_id,</span>
<span class=" -Sql -Sql-Popup">        posts.headline AS posts_headline,</span>
<span class=" -Sql -Sql-Popup">        posts.body AS posts_body</span>
<span class=" -Sql -Sql-Popup">FROM posts</span>
<span class=" -Sql -Sql-Popup">WHERE EXISTS (SELECT 1</span>
<span class=" -Sql -Sql-Popup">    FROM post_keywords, keywords</span>
<span class=" -Sql -Sql-Popup">    WHERE posts.id = post_keywords.post_id</span>
<span class=" -Sql -Sql-Popup">        AND keywords.id = post_keywords.keyword_id</span>
<span class=" -Sql -Sql-Popup">        AND keywords.keyword = ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;firstpost&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[</span><span class="n">BlogPost</span><span class="p">(</span><span class="s2">&quot;Wendy&#39;s Blog Post&quot;</span><span class="p">,</span> <span class="s1">&#39;This is a test&#39;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;windy&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)]</span>
</pre></div>
</div>
<p>만약 user <code class="docutils literal notranslate"><span class="pre">wendy</span></code>가 소유하고 있는 포스트를 찾고 싶으면, 해당 <code class="docutils literal notranslate"><span class="pre">User</span></code> 객체를 부모로 쿼리를 좁힐 수 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">BlogPost</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>             <span class="nb">filter</span><span class="p">(</span><span class="n">BlogPost</span><span class="o">.</span><span class="n">author</span><span class="o">==</span><span class="n">wendy</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span>             <span class="nb">filter</span><span class="p">(</span><span class="n">BlogPost</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">keyword</span><span class="o">=</span><span class="s1">&#39;firstpost&#39;</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span>             <span class="nb">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT posts.id AS posts_id,</span>
<span class=" -Sql -Sql-Popup">        posts.user_id AS posts_user_id,</span>
<span class=" -Sql -Sql-Popup">        posts.headline AS posts_headline,</span>
<span class=" -Sql -Sql-Popup">        posts.body AS posts_body</span>
<span class=" -Sql -Sql-Popup">FROM posts</span>
<span class=" -Sql -Sql-Popup">WHERE ? = posts.user_id AND (EXISTS (SELECT 1</span>
<span class=" -Sql -Sql-Popup">    FROM post_keywords, keywords</span>
<span class=" -Sql -Sql-Popup">    WHERE posts.id = post_keywords.post_id</span>
<span class=" -Sql -Sql-Popup">        AND keywords.id = post_keywords.keyword_id</span>
<span class=" -Sql -Sql-Popup">        AND keywords.keyword = ?))</span>
<span class=" -Sql -Sql-Popup">(2, &#39;firstpost&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[</span><span class="n">BlogPost</span><span class="p">(</span><span class="s2">&quot;Wendy&#39;s Blog Post&quot;</span><span class="p">,</span> <span class="s1">&#39;This is a test&#39;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;windy&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)]</span>
</pre></div>
</div>
<p>또는 &quot;dynamic&quot; relationship인 Wendy 소유의 <code class="docutils literal notranslate"><span class="pre">posts</span></code> relationship을 사용해 거기서 바로 쿼리할 수 있다:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="o">&gt;&gt;&gt;</span> <span class="n">wendy</span><span class="o">.</span><span class="n">posts</span><span class="o">.</span>\
<span class="o">...</span>         <span class="nb">filter</span><span class="p">(</span><span class="n">BlogPost</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">keyword</span><span class="o">=</span><span class="s1">&#39;firstpost&#39;</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span>         <span class="nb">all</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT posts.id AS posts_id,</span>
<span class=" -Sql -Sql-Popup">        posts.user_id AS posts_user_id,</span>
<span class=" -Sql -Sql-Popup">        posts.headline AS posts_headline,</span>
<span class=" -Sql -Sql-Popup">        posts.body AS posts_body</span>
<span class=" -Sql -Sql-Popup">FROM posts</span>
<span class=" -Sql -Sql-Popup">WHERE ? = posts.user_id AND (EXISTS (SELECT 1</span>
<span class=" -Sql -Sql-Popup">    FROM post_keywords, keywords</span>
<span class=" -Sql -Sql-Popup">    WHERE posts.id = post_keywords.post_id</span>
<span class=" -Sql -Sql-Popup">        AND keywords.id = post_keywords.keyword_id</span>
<span class=" -Sql -Sql-Popup">        AND keywords.keyword = ?))</span>
<span class=" -Sql -Sql-Popup">(2, &#39;firstpost&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="p">[</span><span class="n">BlogPost</span><span class="p">(</span><span class="s2">&quot;Wendy&#39;s Blog Post&quot;</span><span class="p">,</span> <span class="s1">&#39;This is a test&#39;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">,</span> <span class="n">nickname</span><span class="o">=</span><span class="s1">&#39;windy&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="section" id="further-reference">
<h2>더 읽어보기<a class="headerlink" href="#further-reference" title="제목 주소">¶</a></h2>
<p>Query Reference: <a class="reference internal" href="query.html#query-api-toplevel"><span class="std std-ref">Query API</span></a></p>
<p>Mapper Reference: <a class="reference internal" href="mapper_config.html#mapper-config-toplevel"><span class="std std-ref">Mapper Configuration</span></a></p>
<p>Relationship Reference: <a class="reference internal" href="relationships.html#relationship-config-toplevel"><span class="std std-ref">Relationship Configuration</span></a></p>
<p>Session Reference: <a class="reference internal" href="session.html"><span class="doc">Using the Session</span></a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mapper_config.html" class="btn btn-neutral float-right" title="Mapper Configuration" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="SQLAlchemy ORM" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
      최종 업데이트: 03/04/2019 18:35:14

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.3.0b1',
            LANGUAGE:'ko',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>