

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ko" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ko" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Microsoft SQL Server &mdash; SQLAlchemy 1.3.0b1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="Firebird" href="firebird.html" />
    <link rel="prev" title="Oracle" href="oracle.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../contents.html" class="icon icon-home"> SQLAlchemy
          

          
          </a>

          
            
            
              <div class="version">
                1.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../orm/index.html">SQLAlchemy ORM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core/index.html">SQLAlchemy Core</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Dialects</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="postgresql.html">PostgreSQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="mysql.html">MySQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="sqlite.html">SQLite</a></li>
<li class="toctree-l2"><a class="reference internal" href="oracle.html">Oracle</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Microsoft SQL Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="firebird.html">Firebird</a></li>
<li class="toctree-l2"><a class="reference internal" href="sybase.html">Sybase</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../errors.html">Error Messages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog/index.html">Changes and Migration</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../contents.html">SQLAlchemy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../contents.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Dialects</a> &raquo;</li>
        
      <li>Microsoft SQL Server</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/VeranosTech/docs-korean-sqlalchemy//docs-korean/doc/build/dialects/mssql.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-sqlalchemy.dialects.mssql.base">
<span id="microsoft-sql-server"></span><span id="mssql-toplevel"></span><h1>Microsoft SQL Server<a class="headerlink" href="#module-sqlalchemy.dialects.mssql.base" title="제목 주소">¶</a></h1>
<div class="section" id="auto-increment-behavior-identity-columns">
<span id="mssql-identity"></span><h2>Auto Increment Behavior / IDENTITY Columns<a class="headerlink" href="#auto-increment-behavior-identity-columns" title="제목 주소">¶</a></h2>
<p>SQL Server provides so-called &quot;auto incrementing&quot; behavior using the
<code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> construct, which can be placed on any single integer column in a
table. SQLAlchemy considers <code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> within its default &quot;autoincrement&quot;
behavior for an integer primary key column, described at
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.autoincrement</span></code></a>.  This means that by default, the first
integer primary key column in a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> will be considered to be the
identity column and will generate DDL as such:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span>
        <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span>
<span class="n">m</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
</pre></div>
</div>
<p>The above example will generate DDL as:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">IDENTITY</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">x</span> <span class="nb">INTEGER</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>For the case where this default generation of <code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> is not desired,
specify <code class="docutils literal notranslate"><span class="pre">False</span></code> for the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.autoincrement</span></code></a> flag,
on the first integer primary key column:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span>
        <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">autoincrement</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span>
<span class="n">m</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
</pre></div>
</div>
<p>To add the <code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> keyword to a non-primary key column, specify
<code class="docutils literal notranslate"><span class="pre">True</span></code> for the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.autoincrement</span></code></a> flag on the desired
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> object, and ensure that <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.autoincrement</span></code></a>
is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> on any integer primary key column:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span>
        <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">autoincrement</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">autoincrement</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="n">m</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 1.3으로 변경: </span>Added <code class="docutils literal notranslate"><span class="pre">mssql_identity_start</span></code> and
<code class="docutils literal notranslate"><span class="pre">mssql_identity_increment</span></code> parameters to <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>.  These replace
the use of the <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> object in order to specify these values.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 1.3 폐지: </span>The use of <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> to specify IDENTITY characteristics is
deprecated and will be removed in a future release.   Please use
the <code class="docutils literal notranslate"><span class="pre">mssql_identity_start</span></code> and <code class="docutils literal notranslate"><span class="pre">mssql_identity_increment</span></code> parameters
documented at <a class="reference internal" href="#mssql-identity"><span class="std std-ref">Auto Increment Behavior / IDENTITY Columns</span></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">There can only be one IDENTITY column on the table.  When using
<code class="docutils literal notranslate"><span class="pre">autoincrement=True</span></code> to enable the IDENTITY keyword, SQLAlchemy does not
guard against multiple columns specifying the option simultaneously.  The
SQL Server database will instead reject the <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> statement.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">An INSERT statement which attempts to provide a value for a column that is
marked with IDENTITY will be rejected by SQL Server.   In order for the
value to be accepted, a session-level option &quot;SET IDENTITY_INSERT&quot; must be
enabled.   The SQLAlchemy SQL Server dialect will perform this operation
automatically when using a core <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a> construct; if the
execution specifies a value for the IDENTITY column, the &quot;IDENTITY_INSERT&quot;
option will be enabled for the span of that statement's invocation.However,
this scenario is not high performing and should not be relied upon for
normal use.   If a table doesn't actually require IDENTITY behavior in its
integer primary key column, the keyword should be disabled when creating
the table by ensuring that <code class="docutils literal notranslate"><span class="pre">autoincrement=False</span></code> is set.</p>
</div>
<div class="section" id="controlling-start-and-increment">
<h3>Controlling &quot;Start&quot; and &quot;Increment&quot;<a class="headerlink" href="#controlling-start-and-increment" title="제목 주소">¶</a></h3>
<p>Specific control over the &quot;start&quot; and &quot;increment&quot; values for
the <code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> generator are provided using the
<code class="docutils literal notranslate"><span class="pre">mssql_identity_start</span></code> and <code class="docutils literal notranslate"><span class="pre">mssql_identity_increment</span></code> parameters
passed to the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Column</span>

<span class="n">test</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span>
        <span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mssql_identity_start</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
         <span class="n">mssql_identity_increment</span><span class="o">=</span><span class="mi">10</span>
    <span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The CREATE TABLE for the above <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object would be:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">test</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">IDENTITY</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 1.3으로 변경: </span>The <code class="docutils literal notranslate"><span class="pre">mssql_identity_start</span></code> and
<code class="docutils literal notranslate"><span class="pre">mssql_identity_increment</span></code> parameters are now used to affect the
<code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> generator for a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> under  SQL Server.
Previously, the <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> object was used.  As SQL Server now
supports real sequences as a separate construct, <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> will be
functional in the normal way in a future SQLAlchemy version.</p>
</div>
</div>
<div class="section" id="insert-behavior">
<h3>INSERT behavior<a class="headerlink" href="#insert-behavior" title="제목 주소">¶</a></h3>
<p>Handling of the <code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> column at INSERT time involves two key
techniques. The most common is being able to fetch the &quot;last inserted value&quot;
for a given <code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> column, a process which SQLAlchemy performs
implicitly in many cases, most importantly within the ORM.</p>
<p>The process for fetching this value has several variants:</p>
<ul>
<li><p class="first">In the vast majority of cases, RETURNING is used in conjunction with INSERT
statements on SQL Server in order to get newly generated primary key values:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">OUTPUT</span> <span class="n">inserted</span><span class="p">.</span><span class="n">id</span> <span class="k">VALUES</span> <span class="p">(</span><span class="o">?</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">When RETURNING is not available or has been disabled via
<code class="docutils literal notranslate"><span class="pre">implicit_returning=False</span></code>, either the <code class="docutils literal notranslate"><span class="pre">scope_identity()</span></code> function or
the <code class="docutils literal notranslate"><span class="pre">&#64;&#64;identity</span></code> variable is used; behavior varies by backend:</p>
<ul>
<li><p class="first">when using PyODBC, the phrase <code class="docutils literal notranslate"><span class="pre">;</span> <span class="pre">select</span> <span class="pre">scope_identity()</span></code> will be
appended to the end of the INSERT statement; a second result set will be
fetched in order to receive the value.  Given a table as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span>
        <span class="n">implicit_returning</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>an INSERT will look like:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="o">?</span><span class="p">);</span> <span class="k">select</span> <span class="n">scope_identity</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p class="first">Other dialects such as pymssql will call upon
<code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">scope_identity()</span> <span class="pre">AS</span> <span class="pre">lastrowid</span></code> subsequent to an INSERT
statement. If the flag <code class="docutils literal notranslate"><span class="pre">use_scope_identity=False</span></code> is passed to
<a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>, the statement <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">&#64;&#64;identity</span> <span class="pre">AS</span> <span class="pre">lastrowid</span></code>
is used instead.</p>
</li>
</ul>
</li>
</ul>
<p>A table that contains an <code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> column will prohibit an INSERT statement
that refers to the identity column explicitly.  The SQLAlchemy dialect will
detect when an INSERT construct, created using a core <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal notranslate"><span class="pre">insert()</span></code></a>
construct (not a plain string SQL), refers to the identity column, and
in this case will emit <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">IDENTITY_INSERT</span> <span class="pre">ON</span></code> prior to the insert
statement proceeding, and <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">IDENTITY_INSERT</span> <span class="pre">OFF</span></code> subsequent to the
execution.  Given this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span>
<span class="n">m</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>

<span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
</pre></div>
</div>
<p>The above column will be created with IDENTITY, however the INSERT statement
we emit is specifying explicit values.  In the echo output we can see
how SQLAlchemy handles this:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">IDENTITY</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">x</span> <span class="nb">INTEGER</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">COMMIT</span>
<span class="k">SET</span> <span class="n">IDENTITY_INSERT</span> <span class="n">t</span> <span class="k">ON</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="o">?</span><span class="p">,</span> <span class="o">?</span><span class="p">)</span>
<span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="k">SET</span> <span class="n">IDENTITY_INSERT</span> <span class="n">t</span> <span class="k">OFF</span>
<span class="k">COMMIT</span>
</pre></div>
</div>
<p>This
is an auxiliary use case suitable for testing and bulk insert scenarios.</p>
</div>
</div>
<div class="section" id="max-on-varchar-nvarchar">
<h2>MAX on VARCHAR / NVARCHAR<a class="headerlink" href="#max-on-varchar-nvarchar" title="제목 주소">¶</a></h2>
<p>SQL Server supports the special string &quot;MAX&quot; within the
<code class="xref py py-class docutils literal notranslate"><span class="pre">sqltypes.VARCHAR</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">sqltypes.NVARCHAR</span></code> datatypes,
to indicate &quot;maximum length possible&quot;.   The dialect currently handles this as
a length of &quot;None&quot; in the base type, rather than supplying a
dialect-specific version of these types, so that a base type
specified such as <code class="docutils literal notranslate"><span class="pre">VARCHAR(None)</span></code> can assume &quot;unlengthed&quot; behavior on
more than one backend without using dialect-specific types.</p>
<p>To build a SQL Server VARCHAR or NVARCHAR with MAX length, use None:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">my_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s1">&#39;my_table&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;my_data&#39;</span><span class="p">,</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;my_n_data&#39;</span><span class="p">,</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="collation-support">
<h2>Collation Support<a class="headerlink" href="#collation-support" title="제목 주소">¶</a></h2>
<p>Character collations are supported by the base string types,
specified by the string argument &quot;collation&quot;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">VARCHAR</span>
<span class="n">Column</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">,</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">collation</span><span class="o">=</span><span class="s1">&#39;Latin1_General_CI_AS&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>When such a column is associated with a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>, the
CREATE TABLE statement for this column will yield:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">login</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="n">COLLATE</span> <span class="n">Latin1_General_CI_AS</span> <span class="n">NULL</span>
</pre></div>
</div>
</div>
<div class="section" id="limit-offset-support">
<h2>LIMIT/OFFSET Support<a class="headerlink" href="#limit-offset-support" title="제목 주소">¶</a></h2>
<p>MSSQL has no support for the LIMIT or OFFSET keywords. LIMIT is
supported directly through the <code class="docutils literal notranslate"><span class="pre">TOP</span></code> Transact SQL keyword:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">select</span><span class="o">.</span><span class="n">limit</span>
</pre></div>
</div>
<p>will yield:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">TOP</span> <span class="n">n</span>
</pre></div>
</div>
<p>If using SQL Server 2005 or above, LIMIT with OFFSET
support is available through the <code class="docutils literal notranslate"><span class="pre">ROW_NUMBER</span> <span class="pre">OVER</span></code> construct.
For versions below 2005, LIMIT with OFFSET usage will fail.</p>
</div>
<div class="section" id="transaction-isolation-level">
<span id="mssql-isolation-level"></span><h2>Transaction Isolation Level<a class="headerlink" href="#transaction-isolation-level" title="제목 주소">¶</a></h2>
<p>All SQL Server dialects support setting of transaction isolation level
both via a dialect-specific parameter
<a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.isolation_level" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.isolation_level</span></code></a>
accepted by <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>,
as well as the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level" title="sqlalchemy.engine.Connection.execution_options"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Connection.execution_options.isolation_level</span></code></a>
argument as passed to
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execution_options" title="sqlalchemy.engine.Connection.execution_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execution_options()</span></code></a>.  This feature works by issuing the
command <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">TRANSACTION</span> <span class="pre">ISOLATION</span> <span class="pre">LEVEL</span> <span class="pre">&lt;level&gt;</span></code> for
each new connection.</p>
<p>To set isolation level using <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span>
    <span class="s2">&quot;mssql+pyodbc://scott:tiger@ms_2008&quot;</span><span class="p">,</span>
    <span class="n">isolation_level</span><span class="o">=</span><span class="s2">&quot;REPEATABLE READ&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>To set using per-connection execution options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span>
    <span class="n">isolation_level</span><span class="o">=</span><span class="s2">&quot;READ COMMITTED&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Valid values for <code class="docutils literal notranslate"><span class="pre">isolation_level</span></code> include:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">AUTOCOMMIT</span></code> - pyodbc / pymssql-specific</li>
<li><code class="docutils literal notranslate"><span class="pre">READ</span> <span class="pre">COMMITTED</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">READ</span> <span class="pre">UNCOMMITTED</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">REPEATABLE</span> <span class="pre">READ</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">SERIALIZABLE</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">SNAPSHOT</span></code> - specific to SQL Server</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">버전 1.1에 추가: </span>support for isolation level setting on Microsoft
SQL Server.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 1.2에 추가: </span>added AUTOCOMMIT isolation level setting</p>
</div>
</div>
<div class="section" id="nullability">
<h2>Nullability<a class="headerlink" href="#nullability" title="제목 주소">¶</a></h2>
<p>MSSQL has support for three levels of column nullability. The default
nullability allows nulls and is explicit in the CREATE TABLE
construct:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="n">NULL</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">nullable=None</span></code> is specified then no specification is made. In
other words the database's configured default is used. This will
render:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">nullable</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> then the column will be
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">NULL</span></code> respectively.</p>
</div>
<div class="section" id="date-time-handling">
<h2>Date / Time Handling<a class="headerlink" href="#date-time-handling" title="제목 주소">¶</a></h2>
<p>DATE and TIME are supported.   Bind parameters are converted
to datetime.datetime() objects as required by most MSSQL drivers,
and results are processed from strings if needed.
The DATE and TIME types are not available for MSSQL 2005 and
previous - if a server version below 2008 is detected, DDL
for these types will be issued as DATETIME.</p>
</div>
<div class="section" id="large-text-binary-type-deprecation">
<span id="mssql-large-type-deprecation"></span><h2>Large Text/Binary Type Deprecation<a class="headerlink" href="#large-text-binary-type-deprecation" title="제목 주소">¶</a></h2>
<p>Per
<a class="reference external" href="http://technet.microsoft.com/en-us/library/ms187993.aspx">SQL Server 2012/2014 Documentation</a>,
the <code class="docutils literal notranslate"><span class="pre">NTEXT</span></code>, <code class="docutils literal notranslate"><span class="pre">TEXT</span></code> and <code class="docutils literal notranslate"><span class="pre">IMAGE</span></code> datatypes are to be removed from SQL
Server in a future release.   SQLAlchemy normally relates these types to the
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.UnicodeText" title="sqlalchemy.types.UnicodeText"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeText</span></code></a>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Text" title="sqlalchemy.types.Text"><code class="xref py py-class docutils literal notranslate"><span class="pre">Text</span></code></a> and <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.LargeBinary" title="sqlalchemy.types.LargeBinary"><code class="xref py py-class docutils literal notranslate"><span class="pre">LargeBinary</span></code></a> datatypes.</p>
<p>In order to accommodate this change, a new flag <code class="docutils literal notranslate"><span class="pre">deprecate_large_types</span></code>
is added to the dialect, which will be automatically set based on detection
of the server version in use, if not otherwise set by the user.  The
behavior of this flag is as follows:</p>
<ul>
<li><p class="first">When this flag is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.UnicodeText" title="sqlalchemy.types.UnicodeText"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeText</span></code></a>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Text" title="sqlalchemy.types.Text"><code class="xref py py-class docutils literal notranslate"><span class="pre">Text</span></code></a> and
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.LargeBinary" title="sqlalchemy.types.LargeBinary"><code class="xref py py-class docutils literal notranslate"><span class="pre">LargeBinary</span></code></a> datatypes, when used to render DDL, will render the
types <code class="docutils literal notranslate"><span class="pre">NVARCHAR(max)</span></code>, <code class="docutils literal notranslate"><span class="pre">VARCHAR(max)</span></code>, and <code class="docutils literal notranslate"><span class="pre">VARBINARY(max)</span></code>,
respectively.  This is a new behavior as of the addition of this flag.</p>
</li>
<li><p class="first">When this flag is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.UnicodeText" title="sqlalchemy.types.UnicodeText"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeText</span></code></a>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Text" title="sqlalchemy.types.Text"><code class="xref py py-class docutils literal notranslate"><span class="pre">Text</span></code></a> and
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.LargeBinary" title="sqlalchemy.types.LargeBinary"><code class="xref py py-class docutils literal notranslate"><span class="pre">LargeBinary</span></code></a> datatypes, when used to render DDL, will render the
types <code class="docutils literal notranslate"><span class="pre">NTEXT</span></code>, <code class="docutils literal notranslate"><span class="pre">TEXT</span></code>, and <code class="docutils literal notranslate"><span class="pre">IMAGE</span></code>,
respectively.  This is the long-standing behavior of these types.</p>
</li>
<li><p class="first">The flag begins with the value <code class="docutils literal notranslate"><span class="pre">None</span></code>, before a database connection is
established.   If the dialect is used to render DDL without the flag being
set, it is interpreted the same as <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</li>
<li><p class="first">On first connection, the dialect detects if SQL Server version 2012 or
greater is in use; if the flag is still at <code class="docutils literal notranslate"><span class="pre">None</span></code>, it sets it to <code class="docutils literal notranslate"><span class="pre">True</span></code>
or <code class="docutils literal notranslate"><span class="pre">False</span></code> based on whether 2012 or greater is detected.</p>
</li>
<li><p class="first">The flag can be set to either <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> when the dialect
is created, typically via <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">eng</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mssql+pymssql://user:pass@host/db&quot;</span><span class="p">,</span>
                <span class="n">deprecate_large_types</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Complete control over whether the &quot;old&quot; or &quot;new&quot; types are rendered is
available in all SQLAlchemy versions by using the UPPERCASE type objects
instead: <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.NVARCHAR" title="sqlalchemy.types.NVARCHAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">NVARCHAR</span></code></a>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.VARCHAR" title="sqlalchemy.types.VARCHAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">VARCHAR</span></code></a>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.VARBINARY" title="sqlalchemy.types.VARBINARY"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.VARBINARY</span></code></a>,
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.TEXT" title="sqlalchemy.types.TEXT"><code class="xref py py-class docutils literal notranslate"><span class="pre">TEXT</span></code></a>, <a class="reference internal" href="#sqlalchemy.dialects.mssql.NTEXT" title="sqlalchemy.dialects.mssql.NTEXT"><code class="xref py py-class docutils literal notranslate"><span class="pre">mssql.NTEXT</span></code></a>, <a class="reference internal" href="#sqlalchemy.dialects.mssql.IMAGE" title="sqlalchemy.dialects.mssql.IMAGE"><code class="xref py py-class docutils literal notranslate"><span class="pre">mssql.IMAGE</span></code></a> will always
remain fixed and always output exactly that type.</p>
</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">버전 1.0.0에 추가.</span></p>
</div>
</div>
<div class="section" id="multipart-schema-names">
<span id="id1"></span><h2>Multipart Schema Names<a class="headerlink" href="#multipart-schema-names" title="제목 주소">¶</a></h2>
<p>SQL Server schemas sometimes require multiple parts to their &quot;schema&quot;
qualifier, that is, including the database name and owner name as separate
tokens, such as <code class="docutils literal notranslate"><span class="pre">mydatabase.dbo.some_table</span></code>. These multipart names can be set
at once using the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.schema" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.schema</span></code></a> argument of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;some_table&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
    <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;mydatabase.dbo&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>When performing operations such as table or component reflection, a schema
argument that contains a dot will be split into separate
&quot;database&quot; and &quot;owner&quot;  components in order to correctly query the SQL
Server information schema tables, as these two values are stored separately.
Additionally, when rendering the schema name for DDL or SQL, the two
components will be quoted separately for case sensitive names and other
special characters.   Given an argument as below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;some_table&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
    <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;MyDataBase.dbo&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The above schema would be rendered as <code class="docutils literal notranslate"><span class="pre">[MyDataBase].dbo</span></code>, and also in
reflection, would be reflected using &quot;dbo&quot; as the owner and &quot;MyDataBase&quot;
as the database name.</p>
<p>To control how the schema name is broken into database / owner,
specify brackets (which in SQL Server are quoting characters) in the name.
Below, the &quot;owner&quot; will be considered as <code class="docutils literal notranslate"><span class="pre">MyDataBase.dbo</span></code> and the
&quot;database&quot; will be None:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;some_table&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
    <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;[MyDataBase.dbo]&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>To individually specify both database and owner name with special characters
or embedded dots, use two sets of brackets:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;some_table&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
    <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;[MyDataBase.Period].[MyOwner.Dot]&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 1.2으로 변경: </span>the SQL Server dialect now treats brackets as
identifier delimeters splitting the schema into separate database
and owner tokens, to allow dots within either name itself.</p>
</div>
</div>
<div class="section" id="legacy-schema-mode">
<span id="legacy-schema-rendering"></span><h2>Legacy Schema Mode<a class="headerlink" href="#legacy-schema-mode" title="제목 주소">¶</a></h2>
<p>Very old versions of the MSSQL dialect introduced the behavior such that a
schema-qualified table would be auto-aliased when used in a
SELECT statement; given a table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">account_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s1">&#39;account&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">100</span><span class="p">)),</span>
    <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;customer_schema&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>this legacy mode of rendering would assume that &quot;customer_schema.account&quot;
would not be accepted by all parts of the SQL statement, as illustrated
below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eng</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mssql+pymssql://mydsn&quot;</span><span class="p">,</span> <span class="n">legacy_schema_aliasing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">account_table</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">eng</span><span class="p">))</span>
<span class="go">SELECT account_1.id, account_1.info</span>
<span class="go">FROM customer_schema.account AS account_1</span>
</pre></div>
</div>
<p>This mode of behavior is now off by default, as it appears to have served
no purpose; however in the case that legacy applications rely upon it,
it is available using the <code class="docutils literal notranslate"><span class="pre">legacy_schema_aliasing</span></code> argument to
<a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> as illustrated above.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 1.1으로 변경: </span>the <code class="docutils literal notranslate"><span class="pre">legacy_schema_aliasing</span></code> flag introduced
in version 1.0.5 to allow disabling of legacy mode for schemas now
defaults to False.</p>
</div>
</div>
<div class="section" id="clustered-index-support">
<span id="mssql-indexes"></span><h2>Clustered Index Support<a class="headerlink" href="#clustered-index-support" title="제목 주소">¶</a></h2>
<p>The MSSQL dialect supports clustered indexes (and primary keys) via the
<code class="docutils literal notranslate"><span class="pre">mssql_clustered</span></code> option.  This option is available to <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index" title="sqlalchemy.schema.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a>,
<a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.UniqueConstraint" title="sqlalchemy.schema.UniqueConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueConstraint</span></code></a>. and <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint" title="sqlalchemy.schema.PrimaryKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrimaryKeyConstraint</span></code></a>.</p>
<p>To generate a clustered index:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Index</span><span class="p">(</span><span class="s2">&quot;my_index&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">mssql_clustered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>which renders the index as <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">CLUSTERED</span> <span class="pre">INDEX</span> <span class="pre">my_index</span> <span class="pre">ON</span> <span class="pre">table</span> <span class="pre">(x)</span></code>.</p>
<p>To generate a clustered primary key use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span><span class="s1">&#39;my_table&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
      <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>
      <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>
      <span class="n">PrimaryKeyConstraint</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">mssql_clustered</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p>which will render the table, for example, as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">my_table</span> <span class="p">(</span><span class="n">x</span> <span class="n">INTEGER</span> <span class="n">NOT</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">y</span> <span class="n">INTEGER</span> <span class="n">NOT</span> <span class="n">NULL</span><span class="p">,</span>
                       <span class="n">PRIMARY</span> <span class="n">KEY</span> <span class="n">CLUSTERED</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>Similarly, we can generate a clustered unique constraint using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span><span class="s1">&#39;my_table&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
      <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>
      <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>
      <span class="n">PrimaryKeyConstraint</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span>
      <span class="n">UniqueConstraint</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">mssql_clustered</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
      <span class="p">)</span>
</pre></div>
</div>
<p>To explicitly request a non-clustered primary key (for example, when
a separate clustered index is desired), use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span><span class="s1">&#39;my_table&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
      <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>
      <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>
      <span class="n">PrimaryKeyConstraint</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">mssql_clustered</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
</pre></div>
</div>
<p>which will render the table, for example, as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">my_table</span> <span class="p">(</span><span class="n">x</span> <span class="n">INTEGER</span> <span class="n">NOT</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">y</span> <span class="n">INTEGER</span> <span class="n">NOT</span> <span class="n">NULL</span><span class="p">,</span>
                       <span class="n">PRIMARY</span> <span class="n">KEY</span> <span class="n">NONCLUSTERED</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 1.1으로 변경: </span>the <code class="docutils literal notranslate"><span class="pre">mssql_clustered</span></code> option now defaults
to None, rather than False.  <code class="docutils literal notranslate"><span class="pre">mssql_clustered=False</span></code> now explicitly
renders the NONCLUSTERED clause, whereas None omits the CLUSTERED
clause entirely, allowing SQL Server defaults to take effect.</p>
</div>
</div>
<div class="section" id="mssql-specific-index-options">
<h2>MSSQL-Specific Index Options<a class="headerlink" href="#mssql-specific-index-options" title="제목 주소">¶</a></h2>
<p>In addition to clustering, the MSSQL dialect supports other special options
for <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index" title="sqlalchemy.schema.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a>.</p>
<div class="section" id="include">
<h3>INCLUDE<a class="headerlink" href="#include" title="제목 주소">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">mssql_include</span></code> option renders INCLUDE(colname) for the given string
names:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Index</span><span class="p">(</span><span class="s2">&quot;my_index&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">mssql_include</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>would render the index as <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">INDEX</span> <span class="pre">my_index</span> <span class="pre">ON</span> <span class="pre">table</span> <span class="pre">(x)</span> <span class="pre">INCLUDE</span> <span class="pre">(y)</span></code></p>
</div>
<div class="section" id="index-ordering">
<h3>Index ordering<a class="headerlink" href="#index-ordering" title="제목 주소">¶</a></h3>
<p>Index ordering is available via functional expressions, such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Index</span><span class="p">(</span><span class="s2">&quot;my_index&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>
</pre></div>
</div>
<p>would render the index as <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">INDEX</span> <span class="pre">my_index</span> <span class="pre">ON</span> <span class="pre">table</span> <span class="pre">(x</span> <span class="pre">DESC)</span></code></p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="../core/constraints.html#schema-indexes-functional"><span class="std std-ref">Functional Indexes</span></a></p>
</div>
</div>
</div>
<div class="section" id="compatibility-levels">
<h2>Compatibility Levels<a class="headerlink" href="#compatibility-levels" title="제목 주소">¶</a></h2>
<p>MSSQL supports the notion of setting compatibility levels at the
database level. This allows, for instance, to run a database that
is compatible with SQL2000 while running on a SQL2005 database
server. <code class="docutils literal notranslate"><span class="pre">server_version_info</span></code> will always return the database
server version information (in this case SQL2005) and not the
compatibility level information. Because of this, if running under
a backwards compatibility mode SQLAlchemy may attempt to use T-SQL
statements that are unable to be parsed by the database server.</p>
</div>
<div class="section" id="triggers">
<h2>Triggers<a class="headerlink" href="#triggers" title="제목 주소">¶</a></h2>
<p>SQLAlchemy by default uses OUTPUT INSERTED to get at newly
generated primary key values via IDENTITY columns or other
server side defaults.   MS-SQL does not
allow the usage of OUTPUT INSERTED on tables that have triggers.
To disable the usage of OUTPUT INSERTED on a per-table basis,
specify <code class="docutils literal notranslate"><span class="pre">implicit_returning=False</span></code> for each <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
which has triggers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span><span class="s1">&#39;mytable&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="c1"># ...,</span>
    <span class="n">implicit_returning</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Declarative form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">__table_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;implicit_returning&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">}</span>
</pre></div>
</div>
<p>This option can also be specified engine-wide using the
<code class="docutils literal notranslate"><span class="pre">implicit_returning=False</span></code> argument on <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>.</p>
</div>
<div class="section" id="rowcount-support-orm-versioning">
<span id="mssql-rowcount-versioning"></span><h2>Rowcount Support / ORM Versioning<a class="headerlink" href="#rowcount-support-orm-versioning" title="제목 주소">¶</a></h2>
<p>The SQL Server drivers may have limited ability to return the number
of rows updated from an UPDATE or DELETE statement.</p>
<p>As of this writing, the PyODBC driver is not able to return a rowcount when
OUTPUT INSERTED is used.  This impacts the SQLAlchemy ORM's versioning feature
in many cases where server-side value generators are in use in that while the
versioning operations can succeed, the ORM cannot always check that an UPDATE
or DELETE statement matched the number of rows expected, which is how it
verifies that the version identifier matched.   When this condition occurs, a
warning will be emitted but the operation will proceed.</p>
<p>The use of OUTPUT INSERTED can be disabled by setting the
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.implicit_returning</span></code></a> flag to <code class="docutils literal notranslate"><span class="pre">False</span></code> on a particular
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>, which in declarative looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTable</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;mytable&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">stuff</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">TIMESTAMP</span><span class="p">(),</span> <span class="n">default</span><span class="o">=</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;DEFAULT&#39;</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;version_id_col&#39;</span><span class="p">:</span> <span class="n">timestamp</span><span class="p">,</span>
        <span class="s1">&#39;version_id_generator&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">__table_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;implicit_returning&#39;</span><span class="p">:</span> <span class="kc">False</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="enabling-snapshot-isolation">
<h2>Enabling Snapshot Isolation<a class="headerlink" href="#enabling-snapshot-isolation" title="제목 주소">¶</a></h2>
<p>SQL Server has a default transaction
isolation mode that locks entire tables, and causes even mildly concurrent
applications to have long held locks and frequent deadlocks.
Enabling snapshot isolation for the database as a whole is recommended
for modern levels of concurrency support.  This is accomplished via the
following ALTER DATABASE commands executed at the SQL prompt:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ALTER</span> <span class="n">DATABASE</span> <span class="n">MyDatabase</span> <span class="n">SET</span> <span class="n">ALLOW_SNAPSHOT_ISOLATION</span> <span class="n">ON</span>

<span class="n">ALTER</span> <span class="n">DATABASE</span> <span class="n">MyDatabase</span> <span class="n">SET</span> <span class="n">READ_COMMITTED_SNAPSHOT</span> <span class="n">ON</span>
</pre></div>
</div>
<p>Background on SQL Server snapshot isolation is available at
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/ms175095.aspx">http://msdn.microsoft.com/en-us/library/ms175095.aspx</a>.</p>
</div>
<div class="section" id="sql-server-data-types">
<h2>SQL Server Data Types<a class="headerlink" href="#sql-server-data-types" title="제목 주소">¶</a></h2>
<p>As with all SQLAlchemy dialects, all UPPERCASE types that are known to be
valid with SQL server are importable from the top level dialect, whether
they originate from <a class="reference internal" href="../core/type_basics.html#module-sqlalchemy.types" title="sqlalchemy.types"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlalchemy.types</span></code></a> or from the local dialect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.mssql</span> <span class="k">import</span> \
    <span class="n">BIGINT</span><span class="p">,</span> <span class="n">BINARY</span><span class="p">,</span> <span class="n">BIT</span><span class="p">,</span> <span class="n">CHAR</span><span class="p">,</span> <span class="n">DATE</span><span class="p">,</span> <span class="n">DATETIME</span><span class="p">,</span> <span class="n">DATETIME2</span><span class="p">,</span> \
    <span class="n">DATETIMEOFFSET</span><span class="p">,</span> <span class="n">DECIMAL</span><span class="p">,</span> <span class="n">FLOAT</span><span class="p">,</span> <span class="n">IMAGE</span><span class="p">,</span> <span class="n">INTEGER</span><span class="p">,</span> <span class="n">MONEY</span><span class="p">,</span> \
    <span class="n">NCHAR</span><span class="p">,</span> <span class="n">NTEXT</span><span class="p">,</span> <span class="n">NUMERIC</span><span class="p">,</span> <span class="n">NVARCHAR</span><span class="p">,</span> <span class="n">REAL</span><span class="p">,</span> <span class="n">SMALLDATETIME</span><span class="p">,</span> \
    <span class="n">SMALLINT</span><span class="p">,</span> <span class="n">SMALLMONEY</span><span class="p">,</span> <span class="n">SQL_VARIANT</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">,</span> <span class="n">TIME</span><span class="p">,</span> \
    <span class="n">TIMESTAMP</span><span class="p">,</span> <span class="n">TINYINT</span><span class="p">,</span> <span class="n">UNIQUEIDENTIFIER</span><span class="p">,</span> <span class="n">VARBINARY</span><span class="p">,</span> <span class="n">VARCHAR</span>
</pre></div>
</div>
<p>Types which are specific to SQL Server, or have SQL Server-specific
construction arguments, are as follows:</p>
<dl class="class">
<dt id="sqlalchemy.dialects.mssql.BIT">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">BIT</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.BIT" title="정의 주소">¶</a></dt>
<dd><dl class="attribute">
<dt id="sqlalchemy.dialects.mssql.BIT.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.BIT.__init__" title="정의 주소">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.CHAR">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">CHAR</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em>, <em>_expect_unicode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.CHAR" title="정의 주소">¶</a></dt>
<dd><p>The SQL CHAR type.</p>
<dl class="method">
<dt id="sqlalchemy.dialects.mssql.CHAR.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em>, <em>_expect_unicode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.CHAR.__init__" title="정의 주소">¶</a></dt>
<dd><p>Create a string-holding type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.dialects.mssql.CHAR.params.length"></span><strong>length</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.CHAR.params.length">¶</a> -- optional, a length for the column for use in
DDL and CAST expressions.  May be safely omitted if no <code class="docutils literal notranslate"><span class="pre">CREATE</span>
<span class="pre">TABLE</span></code> will be issued.  Certain databases may require a
<code class="docutils literal notranslate"><span class="pre">length</span></code> for use in DDL, and will raise an exception when
the <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> DDL is issued if a <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code>
with no length is included.  Whether the value is
interpreted as bytes or characters is database specific.</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.CHAR.params.collation"></span><strong>collation</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.CHAR.params.collation">¶</a> -- <p>Optional, a column-level collation for
use in DDL and CAST expressions.  Renders using the
COLLATE keyword supported by SQLite, MySQL, and PostgreSQL.
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">cast</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">String</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">select</span><span class="p">([</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;some string&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="n">collation</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">))])</span>
<span class="go">SELECT CAST(:param_1 AS VARCHAR COLLATE utf8) AS anon_1</span>
</pre></div>
</div>
</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.CHAR.params.convert_unicode"></span><strong>convert_unicode</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.CHAR.params.convert_unicode">¶</a> -- <p>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> type will assume that
input is to be passed as Python Unicode objects under Python 2,
and results returned as Python Unicode objects.
In the rare circumstance that the DBAPI does not support
Python unicode under Python 2, SQLAlchemy will use its own
encoder/decoder functionality on strings, referring to the
value of the <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.encoding" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.encoding</span></code></a> parameter
parameter passed to <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> as the encoding.</p>
<div class="deprecated">
<p><span class="versionmodified">버전 1.3 폐지: </span>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> parameter is deprecated and will be removed in a future release.  All modern DBAPIs now support Python Unicode directly and this parameter is unnecessary.</p>
</div>
<p>For the extremely rare case that Python Unicode
is to be encoded/decoded by SQLAlchemy on a backend
that <em>does</em> natively support Python Unicode,
the string value <code class="docutils literal notranslate"><span class="pre">&quot;force&quot;</span></code> can be passed here which will
cause SQLAlchemy's encode/decode services to be
used unconditionally.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">SQLAlchemy's unicode-conversion flags and features only apply
to Python 2; in Python 3, all string objects are Unicode objects.
For this reason, as well as the fact that virtually all modern
DBAPIs now support Unicode natively even under Python 2,
the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> flag is inherently a
legacy feature.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">In the vast majority of cases, the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Unicode" title="sqlalchemy.types.Unicode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unicode</span></code></a> or
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.UnicodeText" title="sqlalchemy.types.UnicodeText"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeText</span></code></a> datatypes should be used for a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> that expects to store non-ascii data.  These
datatypes will ensure that the correct types are used on the
database side as well as set up the correct Unicode behaviors
under Python 2.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.convert_unicode" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.convert_unicode</span></code></a> -
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>-wide parameter</p>
</div>
</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.CHAR.params.unicode_error"></span><strong>unicode_error</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.CHAR.params.unicode_error">¶</a> -- <p>Optional, a method to use to handle Unicode
conversion errors. Behaves like the <code class="docutils literal notranslate"><span class="pre">errors</span></code> keyword argument to
the standard library's <code class="docutils literal notranslate"><span class="pre">string.decode()</span></code> functions, requires
that <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> is set to
<code class="docutils literal notranslate"><span class="pre">&quot;force&quot;</span></code></p>
<div class="deprecated">
<p><span class="versionmodified">버전 1.3 폐지: </span>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.unicode_errors" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.unicode_errors</span></code></a> parameter is deprecated and will be removed in a future release.  This parameter is unnecessary for modern Python DBAPIs and degrades performance significantly.</p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.DATETIME2">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">DATETIME2</code><span class="sig-paren">(</span><em>precision=None</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.DATETIME2" title="정의 주소">¶</a></dt>
<dd><dl class="method">
<dt id="sqlalchemy.dialects.mssql.DATETIME2.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>precision=None</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.DATETIME2.__init__" title="정의 주소">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.DATETIMEOFFSET">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">DATETIMEOFFSET</code><span class="sig-paren">(</span><em>precision=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.DATETIMEOFFSET" title="정의 주소">¶</a></dt>
<dd><dl class="method">
<dt id="sqlalchemy.dialects.mssql.DATETIMEOFFSET.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>precision=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.DATETIMEOFFSET.__init__" title="정의 주소">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.IMAGE">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">IMAGE</code><span class="sig-paren">(</span><em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.IMAGE" title="정의 주소">¶</a></dt>
<dd><dl class="method">
<dt id="sqlalchemy.dialects.mssql.IMAGE.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.IMAGE.__init__" title="정의 주소">¶</a></dt>
<dd><p>Construct a LargeBinary type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><span class="target" id="sqlalchemy.dialects.mssql.IMAGE.params.length"></span><strong>length</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.IMAGE.params.length">¶</a> -- optional, a length for the column for use in
DDL statements, for those binary types that accept a length,
such as the MySQL BLOB type.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.MONEY">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">MONEY</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.MONEY" title="정의 주소">¶</a></dt>
<dd><dl class="attribute">
<dt id="sqlalchemy.dialects.mssql.MONEY.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.MONEY.__init__" title="정의 주소">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.NCHAR">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">NCHAR</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.NCHAR" title="정의 주소">¶</a></dt>
<dd><p>The SQL NCHAR type.</p>
<dl class="method">
<dt id="sqlalchemy.dialects.mssql.NCHAR.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.NCHAR.__init__" title="정의 주소">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Unicode" title="sqlalchemy.types.Unicode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unicode</span></code></a> object.</p>
<p>Parameters are the same as that of <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>,
with the exception that <code class="docutils literal notranslate"><span class="pre">convert_unicode</span></code>
defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.NTEXT">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">NTEXT</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.NTEXT" title="정의 주소">¶</a></dt>
<dd><p>MSSQL NTEXT type, for variable-length unicode text up to 2^30
characters.</p>
<dl class="method">
<dt id="sqlalchemy.dialects.mssql.NTEXT.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.NTEXT.__init__" title="정의 주소">¶</a></dt>
<dd><p>Create a Unicode-converting Text type.</p>
<p>Parameters are the same as that of <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Text" title="sqlalchemy.types.Text"><code class="xref py py-class docutils literal notranslate"><span class="pre">Text</span></code></a>,
with the exception that <code class="docutils literal notranslate"><span class="pre">convert_unicode</span></code>
defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.NVARCHAR">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">NVARCHAR</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.NVARCHAR" title="정의 주소">¶</a></dt>
<dd><p>The SQL NVARCHAR type.</p>
<dl class="method">
<dt id="sqlalchemy.dialects.mssql.NVARCHAR.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.NVARCHAR.__init__" title="정의 주소">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Unicode" title="sqlalchemy.types.Unicode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unicode</span></code></a> object.</p>
<p>Parameters are the same as that of <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>,
with the exception that <code class="docutils literal notranslate"><span class="pre">convert_unicode</span></code>
defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.REAL">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">REAL</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.REAL" title="정의 주소">¶</a></dt>
<dd><dl class="method">
<dt id="sqlalchemy.dialects.mssql.REAL.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.REAL.__init__" title="정의 주소">¶</a></dt>
<dd><p>Construct a Float.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.dialects.mssql.REAL.params.precision"></span><strong>precision</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.REAL.params.precision">¶</a> -- the numeric precision for use in DDL <code class="docutils literal notranslate"><span class="pre">CREATE</span>
<span class="pre">TABLE</span></code>.</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.REAL.params.asdecimal"></span><strong>asdecimal</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.REAL.params.asdecimal">¶</a> -- the same flag as that of <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Numeric" title="sqlalchemy.types.Numeric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Numeric</span></code></a>, but
defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.   Note that setting this flag to <code class="docutils literal notranslate"><span class="pre">True</span></code>
results in floating point conversion.</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.REAL.params.decimal_return_scale"></span><strong>decimal_return_scale</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.REAL.params.decimal_return_scale">¶</a> -- <p>Default scale to use when converting
from floats to Python decimals.  Floating point values will typically
be much longer due to decimal inaccuracy, and most floating point
database types don't have a notion of &quot;scale&quot;, so by default the
float type looks for the first ten decimal places when converting.
Specifying this value will override that length.  Note that the
MySQL float types, which do include &quot;scale&quot;, will use &quot;scale&quot;
as the default for decimal_return_scale, if not otherwise specified.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 0.9.0에 추가.</span></p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.ROWVERSION">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">ROWVERSION</code><span class="sig-paren">(</span><em>convert_int=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.ROWVERSION" title="정의 주소">¶</a></dt>
<dd><p>Implement the SQL Server ROWVERSION type.</p>
<p>The ROWVERSION datatype is a SQL Server synonym for the TIMESTAMP
datatype, however current SQL Server documentation suggests using
ROWVERSION for new datatypes going forward.</p>
<p>The ROWVERSION datatype does <strong>not</strong> reflect (e.g. introspect) from the
database as itself; the returned datatype will be
<a class="reference internal" href="#sqlalchemy.dialects.mssql.TIMESTAMP" title="sqlalchemy.dialects.mssql.TIMESTAMP"><code class="xref py py-class docutils literal notranslate"><span class="pre">mssql.TIMESTAMP</span></code></a>.</p>
<p>This is a read-only datatype that does not support INSERT of values.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 1.2에 추가.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#sqlalchemy.dialects.mssql.TIMESTAMP" title="sqlalchemy.dialects.mssql.TIMESTAMP"><code class="xref py py-class docutils literal notranslate"><span class="pre">mssql.TIMESTAMP</span></code></a></p>
</div>
<dl class="method">
<dt id="sqlalchemy.dialects.mssql.ROWVERSION.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>convert_int=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.ROWVERSION.__init__" title="정의 주소">¶</a></dt>
<dd><p>Construct a TIMESTAMP or ROWVERSION type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><span class="target" id="sqlalchemy.dialects.mssql.ROWVERSION.params.convert_int"></span><strong>convert_int</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.ROWVERSION.params.convert_int">¶</a> -- if True, binary integer values will
be converted to integers on read.</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">버전 1.2에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.SMALLDATETIME">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">SMALLDATETIME</code><span class="sig-paren">(</span><em>timezone=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.SMALLDATETIME" title="정의 주소">¶</a></dt>
<dd><dl class="method">
<dt id="sqlalchemy.dialects.mssql.SMALLDATETIME.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>timezone=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.SMALLDATETIME.__init__" title="정의 주소">¶</a></dt>
<dd><p>Construct a new <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><span class="target" id="sqlalchemy.dialects.mssql.SMALLDATETIME.params.timezone"></span><strong>timezone</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.SMALLDATETIME.params.timezone">¶</a> -- boolean.  Indicates that the datetime type should
enable timezone support, if available on the
<strong>base date/time-holding type only</strong>.   It is recommended
to make use of the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.TIMESTAMP" title="sqlalchemy.types.TIMESTAMP"><code class="xref py py-class docutils literal notranslate"><span class="pre">TIMESTAMP</span></code></a> datatype directly when
using this flag, as some databases include separate generic
date/time-holding types distinct from the timezone-capable
TIMESTAMP datatype, such as Oracle.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.SMALLMONEY">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">SMALLMONEY</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.SMALLMONEY" title="정의 주소">¶</a></dt>
<dd><dl class="attribute">
<dt id="sqlalchemy.dialects.mssql.SMALLMONEY.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.SMALLMONEY.__init__" title="정의 주소">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.SQL_VARIANT">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">SQL_VARIANT</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.SQL_VARIANT" title="정의 주소">¶</a></dt>
<dd><dl class="attribute">
<dt id="sqlalchemy.dialects.mssql.SQL_VARIANT.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.SQL_VARIANT.__init__" title="정의 주소">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.TEXT">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">TEXT</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em>, <em>_expect_unicode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.TEXT" title="정의 주소">¶</a></dt>
<dd><p>The SQL TEXT type.</p>
<dl class="method">
<dt id="sqlalchemy.dialects.mssql.TEXT.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em>, <em>_expect_unicode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.TEXT.__init__" title="정의 주소">¶</a></dt>
<dd><p>Create a string-holding type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.dialects.mssql.TEXT.params.length"></span><strong>length</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.TEXT.params.length">¶</a> -- optional, a length for the column for use in
DDL and CAST expressions.  May be safely omitted if no <code class="docutils literal notranslate"><span class="pre">CREATE</span>
<span class="pre">TABLE</span></code> will be issued.  Certain databases may require a
<code class="docutils literal notranslate"><span class="pre">length</span></code> for use in DDL, and will raise an exception when
the <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> DDL is issued if a <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code>
with no length is included.  Whether the value is
interpreted as bytes or characters is database specific.</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.TEXT.params.collation"></span><strong>collation</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.TEXT.params.collation">¶</a> -- <p>Optional, a column-level collation for
use in DDL and CAST expressions.  Renders using the
COLLATE keyword supported by SQLite, MySQL, and PostgreSQL.
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">cast</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">String</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">select</span><span class="p">([</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;some string&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="n">collation</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">))])</span>
<span class="go">SELECT CAST(:param_1 AS VARCHAR COLLATE utf8) AS anon_1</span>
</pre></div>
</div>
</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.TEXT.params.convert_unicode"></span><strong>convert_unicode</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.TEXT.params.convert_unicode">¶</a> -- <p>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> type will assume that
input is to be passed as Python Unicode objects under Python 2,
and results returned as Python Unicode objects.
In the rare circumstance that the DBAPI does not support
Python unicode under Python 2, SQLAlchemy will use its own
encoder/decoder functionality on strings, referring to the
value of the <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.encoding" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.encoding</span></code></a> parameter
parameter passed to <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> as the encoding.</p>
<div class="deprecated">
<p><span class="versionmodified">버전 1.3 폐지: </span>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> parameter is deprecated and will be removed in a future release.  All modern DBAPIs now support Python Unicode directly and this parameter is unnecessary.</p>
</div>
<p>For the extremely rare case that Python Unicode
is to be encoded/decoded by SQLAlchemy on a backend
that <em>does</em> natively support Python Unicode,
the string value <code class="docutils literal notranslate"><span class="pre">&quot;force&quot;</span></code> can be passed here which will
cause SQLAlchemy's encode/decode services to be
used unconditionally.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">SQLAlchemy's unicode-conversion flags and features only apply
to Python 2; in Python 3, all string objects are Unicode objects.
For this reason, as well as the fact that virtually all modern
DBAPIs now support Unicode natively even under Python 2,
the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> flag is inherently a
legacy feature.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">In the vast majority of cases, the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Unicode" title="sqlalchemy.types.Unicode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unicode</span></code></a> or
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.UnicodeText" title="sqlalchemy.types.UnicodeText"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeText</span></code></a> datatypes should be used for a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> that expects to store non-ascii data.  These
datatypes will ensure that the correct types are used on the
database side as well as set up the correct Unicode behaviors
under Python 2.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.convert_unicode" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.convert_unicode</span></code></a> -
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>-wide parameter</p>
</div>
</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.TEXT.params.unicode_error"></span><strong>unicode_error</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.TEXT.params.unicode_error">¶</a> -- <p>Optional, a method to use to handle Unicode
conversion errors. Behaves like the <code class="docutils literal notranslate"><span class="pre">errors</span></code> keyword argument to
the standard library's <code class="docutils literal notranslate"><span class="pre">string.decode()</span></code> functions, requires
that <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> is set to
<code class="docutils literal notranslate"><span class="pre">&quot;force&quot;</span></code></p>
<div class="deprecated">
<p><span class="versionmodified">버전 1.3 폐지: </span>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.unicode_errors" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.unicode_errors</span></code></a> parameter is deprecated and will be removed in a future release.  This parameter is unnecessary for modern Python DBAPIs and degrades performance significantly.</p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.TIME">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">TIME</code><span class="sig-paren">(</span><em>precision=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.TIME" title="정의 주소">¶</a></dt>
<dd><dl class="method">
<dt id="sqlalchemy.dialects.mssql.TIME.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>precision=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.TIME.__init__" title="정의 주소">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.TIMESTAMP">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">TIMESTAMP</code><span class="sig-paren">(</span><em>convert_int=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.TIMESTAMP" title="정의 주소">¶</a></dt>
<dd><p>Implement the SQL Server TIMESTAMP type.</p>
<p>Note this is <strong>completely different</strong> than the SQL Standard
TIMESTAMP type, which is not supported by SQL Server.  It
is a read-only datatype that does not support INSERT of values.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 1.2에 추가.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#sqlalchemy.dialects.mssql.ROWVERSION" title="sqlalchemy.dialects.mssql.ROWVERSION"><code class="xref py py-class docutils literal notranslate"><span class="pre">mssql.ROWVERSION</span></code></a></p>
</div>
<dl class="method">
<dt id="sqlalchemy.dialects.mssql.TIMESTAMP.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>convert_int=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.TIMESTAMP.__init__" title="정의 주소">¶</a></dt>
<dd><p>Construct a TIMESTAMP or ROWVERSION type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><span class="target" id="sqlalchemy.dialects.mssql.TIMESTAMP.params.convert_int"></span><strong>convert_int</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.TIMESTAMP.params.convert_int">¶</a> -- if True, binary integer values will
be converted to integers on read.</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">버전 1.2에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.TINYINT">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">TINYINT</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.TINYINT" title="정의 주소">¶</a></dt>
<dd><dl class="attribute">
<dt id="sqlalchemy.dialects.mssql.TINYINT.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.TINYINT.__init__" title="정의 주소">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">UNIQUEIDENTIFIER</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER" title="정의 주소">¶</a></dt>
<dd><dl class="attribute">
<dt id="sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER.__init__" title="정의 주소">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.VARCHAR">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">VARCHAR</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em>, <em>_expect_unicode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.VARCHAR" title="정의 주소">¶</a></dt>
<dd><p>The SQL VARCHAR type.</p>
<dl class="method">
<dt id="sqlalchemy.dialects.mssql.VARCHAR.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em>, <em>_expect_unicode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.VARCHAR.__init__" title="정의 주소">¶</a></dt>
<dd><p>Create a string-holding type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.dialects.mssql.VARCHAR.params.length"></span><strong>length</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.VARCHAR.params.length">¶</a> -- optional, a length for the column for use in
DDL and CAST expressions.  May be safely omitted if no <code class="docutils literal notranslate"><span class="pre">CREATE</span>
<span class="pre">TABLE</span></code> will be issued.  Certain databases may require a
<code class="docutils literal notranslate"><span class="pre">length</span></code> for use in DDL, and will raise an exception when
the <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> DDL is issued if a <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code>
with no length is included.  Whether the value is
interpreted as bytes or characters is database specific.</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.VARCHAR.params.collation"></span><strong>collation</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.VARCHAR.params.collation">¶</a> -- <p>Optional, a column-level collation for
use in DDL and CAST expressions.  Renders using the
COLLATE keyword supported by SQLite, MySQL, and PostgreSQL.
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">cast</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">String</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">select</span><span class="p">([</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;some string&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="n">collation</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">))])</span>
<span class="go">SELECT CAST(:param_1 AS VARCHAR COLLATE utf8) AS anon_1</span>
</pre></div>
</div>
</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.VARCHAR.params.convert_unicode"></span><strong>convert_unicode</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.VARCHAR.params.convert_unicode">¶</a> -- <p>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> type will assume that
input is to be passed as Python Unicode objects under Python 2,
and results returned as Python Unicode objects.
In the rare circumstance that the DBAPI does not support
Python unicode under Python 2, SQLAlchemy will use its own
encoder/decoder functionality on strings, referring to the
value of the <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.encoding" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.encoding</span></code></a> parameter
parameter passed to <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> as the encoding.</p>
<div class="deprecated">
<p><span class="versionmodified">버전 1.3 폐지: </span>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> parameter is deprecated and will be removed in a future release.  All modern DBAPIs now support Python Unicode directly and this parameter is unnecessary.</p>
</div>
<p>For the extremely rare case that Python Unicode
is to be encoded/decoded by SQLAlchemy on a backend
that <em>does</em> natively support Python Unicode,
the string value <code class="docutils literal notranslate"><span class="pre">&quot;force&quot;</span></code> can be passed here which will
cause SQLAlchemy's encode/decode services to be
used unconditionally.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">SQLAlchemy's unicode-conversion flags and features only apply
to Python 2; in Python 3, all string objects are Unicode objects.
For this reason, as well as the fact that virtually all modern
DBAPIs now support Unicode natively even under Python 2,
the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> flag is inherently a
legacy feature.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">In the vast majority of cases, the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Unicode" title="sqlalchemy.types.Unicode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unicode</span></code></a> or
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.UnicodeText" title="sqlalchemy.types.UnicodeText"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeText</span></code></a> datatypes should be used for a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> that expects to store non-ascii data.  These
datatypes will ensure that the correct types are used on the
database side as well as set up the correct Unicode behaviors
under Python 2.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.convert_unicode" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.convert_unicode</span></code></a> -
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>-wide parameter</p>
</div>
</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.VARCHAR.params.unicode_error"></span><strong>unicode_error</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.VARCHAR.params.unicode_error">¶</a> -- <p>Optional, a method to use to handle Unicode
conversion errors. Behaves like the <code class="docutils literal notranslate"><span class="pre">errors</span></code> keyword argument to
the standard library's <code class="docutils literal notranslate"><span class="pre">string.decode()</span></code> functions, requires
that <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> is set to
<code class="docutils literal notranslate"><span class="pre">&quot;force&quot;</span></code></p>
<div class="deprecated">
<p><span class="versionmodified">버전 1.3 폐지: </span>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.unicode_errors" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.unicode_errors</span></code></a> parameter is deprecated and will be removed in a future release.  This parameter is unnecessary for modern Python DBAPIs and degrades performance significantly.</p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.mssql.XML">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.mssql.</code><code class="descname">XML</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em>, <em>_expect_unicode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.XML" title="정의 주소">¶</a></dt>
<dd><p>MSSQL XML type.</p>
<p>This is a placeholder type for reflection purposes that does not include
any Python-side datatype support.   It also does not currently support
additional arguments, such as &quot;CONTENT&quot;, &quot;DOCUMENT&quot;,
&quot;xml_schema_collection&quot;.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 1.1.11에 추가.</span></p>
</div>
<dl class="method">
<dt id="sqlalchemy.dialects.mssql.XML.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em>, <em>_expect_unicode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.mssql.XML.__init__" title="정의 주소">¶</a></dt>
<dd><p>Create a string-holding type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.dialects.mssql.XML.params.length"></span><strong>length</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.XML.params.length">¶</a> -- optional, a length for the column for use in
DDL and CAST expressions.  May be safely omitted if no <code class="docutils literal notranslate"><span class="pre">CREATE</span>
<span class="pre">TABLE</span></code> will be issued.  Certain databases may require a
<code class="docutils literal notranslate"><span class="pre">length</span></code> for use in DDL, and will raise an exception when
the <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> DDL is issued if a <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code>
with no length is included.  Whether the value is
interpreted as bytes or characters is database specific.</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.XML.params.collation"></span><strong>collation</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.XML.params.collation">¶</a> -- <p>Optional, a column-level collation for
use in DDL and CAST expressions.  Renders using the
COLLATE keyword supported by SQLite, MySQL, and PostgreSQL.
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">cast</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">String</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">select</span><span class="p">([</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;some string&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="n">collation</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">))])</span>
<span class="go">SELECT CAST(:param_1 AS VARCHAR COLLATE utf8) AS anon_1</span>
</pre></div>
</div>
</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.XML.params.convert_unicode"></span><strong>convert_unicode</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.XML.params.convert_unicode">¶</a> -- <p>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> type will assume that
input is to be passed as Python Unicode objects under Python 2,
and results returned as Python Unicode objects.
In the rare circumstance that the DBAPI does not support
Python unicode under Python 2, SQLAlchemy will use its own
encoder/decoder functionality on strings, referring to the
value of the <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.encoding" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.encoding</span></code></a> parameter
parameter passed to <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> as the encoding.</p>
<div class="deprecated">
<p><span class="versionmodified">버전 1.3 폐지: </span>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> parameter is deprecated and will be removed in a future release.  All modern DBAPIs now support Python Unicode directly and this parameter is unnecessary.</p>
</div>
<p>For the extremely rare case that Python Unicode
is to be encoded/decoded by SQLAlchemy on a backend
that <em>does</em> natively support Python Unicode,
the string value <code class="docutils literal notranslate"><span class="pre">&quot;force&quot;</span></code> can be passed here which will
cause SQLAlchemy's encode/decode services to be
used unconditionally.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">SQLAlchemy's unicode-conversion flags and features only apply
to Python 2; in Python 3, all string objects are Unicode objects.
For this reason, as well as the fact that virtually all modern
DBAPIs now support Unicode natively even under Python 2,
the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> flag is inherently a
legacy feature.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">In the vast majority of cases, the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Unicode" title="sqlalchemy.types.Unicode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unicode</span></code></a> or
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.UnicodeText" title="sqlalchemy.types.UnicodeText"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeText</span></code></a> datatypes should be used for a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> that expects to store non-ascii data.  These
datatypes will ensure that the correct types are used on the
database side as well as set up the correct Unicode behaviors
under Python 2.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.convert_unicode" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.convert_unicode</span></code></a> -
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>-wide parameter</p>
</div>
</li>
<li><span class="target" id="sqlalchemy.dialects.mssql.XML.params.unicode_error"></span><strong>unicode_error</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.mssql.XML.params.unicode_error">¶</a> -- <p>Optional, a method to use to handle Unicode
conversion errors. Behaves like the <code class="docutils literal notranslate"><span class="pre">errors</span></code> keyword argument to
the standard library's <code class="docutils literal notranslate"><span class="pre">string.decode()</span></code> functions, requires
that <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.convert_unicode</span></code></a> is set to
<code class="docutils literal notranslate"><span class="pre">&quot;force&quot;</span></code></p>
<div class="deprecated">
<p><span class="versionmodified">버전 1.3 폐지: </span>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.params.unicode_errors" title="sqlalchemy.types.String"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">String.unicode_errors</span></code></a> parameter is deprecated and will be removed in a future release.  This parameter is unnecessary for modern Python DBAPIs and degrades performance significantly.</p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-sqlalchemy.dialects.mssql.pyodbc">
<span id="pyodbc"></span><h2>PyODBC<a class="headerlink" href="#module-sqlalchemy.dialects.mssql.pyodbc" title="제목 주소">¶</a></h2>
<div class="section" id="connecting-to-pyodbc">
<h3>Connecting to PyODBC<a class="headerlink" href="#connecting-to-pyodbc" title="제목 주소">¶</a></h3>
<p>The URL here is to be translated to PyODBC connection strings, as
detailed in <a class="reference external" href="https://code.google.com/p/pyodbc/wiki/ConnectionStrings">ConnectionStrings</a>.</p>
<div class="section" id="dsn-connections">
<h4>DSN Connections<a class="headerlink" href="#dsn-connections" title="제목 주소">¶</a></h4>
<p>A DSN-based connection is <strong>preferred</strong> overall when using ODBC.  A
basic DSN-based connection looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mssql+pyodbc://scott:tiger@some_dsn&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Which above, will pass the following connection string to PyODBC:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dsn</span><span class="o">=</span><span class="n">mydsn</span><span class="p">;</span><span class="n">UID</span><span class="o">=</span><span class="n">user</span><span class="p">;</span><span class="n">PWD</span><span class="o">=</span><span class="k">pass</span>
</pre></div>
</div>
<p>If the username and password are omitted, the DSN form will also add
the <code class="docutils literal notranslate"><span class="pre">Trusted_Connection=yes</span></code> directive to the ODBC string.</p>
</div>
<div class="section" id="hostname-connections">
<h4>Hostname Connections<a class="headerlink" href="#hostname-connections" title="제목 주소">¶</a></h4>
<p>Hostname-based connections are <strong>not preferred</strong>, however are supported.
The ODBC driver name must be explicitly specified:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mssql+pyodbc://scott:tiger@myhost:port/databasename?driver=SQL+Server+Native+Client+10.0&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 1.0.0으로 변경: </span>Hostname-based PyODBC connections now require the
SQL Server driver name specified explicitly.  SQLAlchemy cannot
choose an optimal default here as it varies based on platform
and installed drivers.</p>
</div>
<p>Other keywords interpreted by the Pyodbc dialect to be passed to
<code class="docutils literal notranslate"><span class="pre">pyodbc.connect()</span></code> in both the DSN and hostname cases include:
<code class="docutils literal notranslate"><span class="pre">odbc_autotranslate</span></code>, <code class="docutils literal notranslate"><span class="pre">ansi</span></code>, <code class="docutils literal notranslate"><span class="pre">unicode_results</span></code>, <code class="docutils literal notranslate"><span class="pre">autocommit</span></code>.</p>
</div>
<div class="section" id="pass-through-exact-pyodbc-string">
<h4>Pass through exact Pyodbc string<a class="headerlink" href="#pass-through-exact-pyodbc-string" title="제목 주소">¶</a></h4>
<p>A PyODBC connection string can also be sent exactly as specified in
<a class="reference external" href="https://code.google.com/p/pyodbc/wiki/ConnectionStrings">ConnectionStrings</a>
into the driver using the parameter <code class="docutils literal notranslate"><span class="pre">odbc_connect</span></code>.  The delimeters must be
URL escaped, however, as illustrated below using <code class="docutils literal notranslate"><span class="pre">urllib.quote_plus</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">quote_plus</span><span class="p">(</span><span class="s2">&quot;DRIVER={SQL Server Native Client 10.0};SERVER=dagger;DATABASE=test;UID=user;PWD=password&quot;</span><span class="p">)</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mssql+pyodbc:///?odbc_connect=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="driver-unicode-support">
<h3>Driver / Unicode Support<a class="headerlink" href="#driver-unicode-support" title="제목 주소">¶</a></h3>
<p>PyODBC works best with Microsoft ODBC drivers, particularly in the area
of Unicode support on both Python 2 and Python 3.</p>
<p>Using the FreeTDS ODBC drivers on Linux or OSX with PyODBC is <strong>not</strong>
recommended; there have been historically many Unicode-related issues
in this area, including before Microsoft offered ODBC drivers for Linux
and OSX.   Now that Microsoft offers drivers for all platforms, for
PyODBC support these are recommended.  FreeTDS remains relevant for
non-ODBC drivers such as pymssql where it works very well.</p>
</div>
<div class="section" id="rowcount-support">
<h3>Rowcount Support<a class="headerlink" href="#rowcount-support" title="제목 주소">¶</a></h3>
<p>Pyodbc only has partial support for rowcount.  See the notes at
<a class="reference internal" href="#mssql-rowcount-versioning"><span class="std std-ref">Rowcount Support / ORM Versioning</span></a> for important notes when using ORM
versioning.</p>
</div>
<div class="section" id="fast-executemany-mode">
<span id="mssql-pyodbc-fastexecutemany"></span><h3>Fast Executemany Mode<a class="headerlink" href="#fast-executemany-mode" title="제목 주소">¶</a></h3>
<p>The Pyodbc driver has added support for a &quot;fast executemany&quot; mode of execution
which greatly reduces round trips for a DBAPI <code class="docutils literal notranslate"><span class="pre">executemany()</span></code> call when using
Microsoft ODBC drivers.  The feature is enabled by setting the flag
<code class="docutils literal notranslate"><span class="pre">.fast_executemany</span></code> on the DBAPI cursor when an executemany call is to be
used.   The SQLAlchemy pyodbc SQL Server dialect supports setting this flag
automatically when the <code class="docutils literal notranslate"><span class="pre">.fast_executemany</span></code> flag is passed to
<a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>; note that the ODBC driver must be the Microsoft driver
in order to use this flag:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span>
    <span class="s2">&quot;mssql+pyodbc://scott:tiger@mssql2017:1433/test?driver=ODBC+Driver+13+for+SQL+Server&quot;</span><span class="p">,</span>
    <span class="n">fast_executemany</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 1.3에 추가.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference external" href="https://github.com/mkleehammer/pyodbc/wiki/Features-beyond-the-DB-API#fast_executemany">fast executemany</a>
- on github</p>
</div>
</div>
</div>
<div class="section" id="module-sqlalchemy.dialects.mssql.mxodbc">
<span id="mxodbc"></span><h2>mxODBC<a class="headerlink" href="#module-sqlalchemy.dialects.mssql.mxodbc" title="제목 주소">¶</a></h2>
<div class="section" id="execution-modes">
<h3>Execution Modes<a class="headerlink" href="#execution-modes" title="제목 주소">¶</a></h3>
<p>mxODBC features two styles of statement execution, using the
<code class="docutils literal notranslate"><span class="pre">cursor.execute()</span></code> and <code class="docutils literal notranslate"><span class="pre">cursor.executedirect()</span></code> methods (the second being
an extension to the DBAPI specification). The former makes use of a particular
API call specific to the SQL Server Native Client ODBC driver known
SQLDescribeParam, while the latter does not.</p>
<p>mxODBC apparently only makes repeated use of a single prepared statement
when SQLDescribeParam is used. The advantage to prepared statement reuse is
one of performance. The disadvantage is that SQLDescribeParam has a limited
set of scenarios in which bind parameters are understood, including that they
cannot be placed within the argument lists of function calls, anywhere outside
the FROM, or even within subqueries within the FROM clause - making the usage
of bind parameters within SELECT statements impossible for all but the most
simplistic statements.</p>
<p>For this reason, the mxODBC dialect uses the &quot;native&quot; mode by default only for
INSERT, UPDATE, and DELETE statements, and uses the escaped string mode for
all other statements.</p>
<p>This behavior can be controlled via
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options" title="sqlalchemy.sql.expression.Executable.execution_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execution_options()</span></code></a> using the
<code class="docutils literal notranslate"><span class="pre">native_odbc_execute</span></code> flag with a value of <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, where a
value of <code class="docutils literal notranslate"><span class="pre">True</span></code> will unconditionally use native bind parameters and a value
of <code class="docutils literal notranslate"><span class="pre">False</span></code> will unconditionally use string-escaped parameters.</p>
</div>
</div>
<div class="section" id="module-sqlalchemy.dialects.mssql.pymssql">
<span id="pymssql"></span><h2>pymssql<a class="headerlink" href="#module-sqlalchemy.dialects.mssql.pymssql" title="제목 주소">¶</a></h2>
<p>pymssql is a Python module that provides a Python DBAPI interface around
<a class="reference external" href="http://www.freetds.org/">FreeTDS</a>.  Compatible builds are available for
Linux, MacOSX and Windows platforms.</p>
<p>Modern versions of this driver work very well with SQL Server and
FreeTDS from Linux and is highly recommended.</p>
</div>
<div class="section" id="module-sqlalchemy.dialects.mssql.zxjdbc">
<span id="zxjdbc"></span><h2>zxjdbc<a class="headerlink" href="#module-sqlalchemy.dialects.mssql.zxjdbc" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-sqlalchemy.dialects.mssql.adodbapi">
<span id="adodbapi"></span><h2>AdoDBAPI<a class="headerlink" href="#module-sqlalchemy.dialects.mssql.adodbapi" title="제목 주소">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">The adodbapi dialect is not implemented SQLAlchemy versions 0.6 and
above at this time.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="firebird.html" class="btn btn-neutral float-right" title="Firebird" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="oracle.html" class="btn btn-neutral" title="Oracle" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
      최종 업데이트: 03/04/2019 18:35:14

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.3.0b1',
            LANGUAGE:'ko',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>